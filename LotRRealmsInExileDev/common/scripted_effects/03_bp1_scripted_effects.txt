##### FAMILY FEUD #####

### START EFFECTS ###

# Start Feud, set variables, modifiers, relations, and stress
house_feud_start_effect = {
	# Save scopes
	$ACTOR$.house.house_head = { save_scope_as = starter_house_head }
	$TARGET$.house.house_head = { save_scope_as = house_feud_rival }
	$ATTACKER$ = { save_scope_as = house_feud_attacker }
	$VICTIM$ = { save_scope_as = house_feud_victim }
	# Save extra scopes if relevant
	save_scope_value_as = {
		name = house_feud_reason
		value = flag:$REASON$
	}
	if = {
		limit = {
			scope:house_feud_reason = flag:competing_claim
			NOT = { exists = scope:house_feud_claim }
		}
		scope:house_feud_victim = {
			ordered_claim = {
				limit = { any_claimant = { this = scope:house_feud_attacker } }
				order_by = tier
				save_scope_as = house_feud_claim
			}
		}
	}
	if = {
		limit = {
			scope:starter_house_head.house != scope:house_feud_rival.house
			house_relation_is_valid_to_start_trigger = {
				HOUSE = scope:starter_house_head.house
				OTHER_HOUSE = scope:house_feud_rival.house
			}
		}
		# Save target House for reference
		scope:starter_house_head ?= {
			house = {
				set_house_relation = {
					target = scope:house_feud_rival.house
					level = feud
					description = house_relation_reason_feud_$REASON$
					save_scope_as = relation
				}
			}
			scope:relation ?= {
				set_variable = {
					name = house_feud_cooldown
					years = 25
				}
			}
		}
		scope:starter_house_head ?= {
			# Relations: Nemesis if already Rivals, else Rival
			if = {
				limit = {
					has_relation_rival = scope:house_feud_rival
					NOT = { has_relation_nemesis = scope:house_feud_rival }
					can_set_relation_nemesis_trigger = { CHARACTER = scope:house_feud_rival }
				}
				set_relation_nemesis = {
					reason = nemesis_house_feud
					copy_reason = rival
					target = scope:house_feud_rival
				}
			}
			else_if = {
				limit = {
					NOT = { has_relation_rival = scope:house_feud_rival }
				}
				set_relation_rival = {
					target = scope:house_feud_rival
					reason = rival_house_feud_start_of_feud
				}
			}
			# Stress
			stress_impact = { vengeful = minor_stress_impact_loss }
			house_feud_forgiving_stress_effect = yes
		}
		# Save reasons for reference
		scope:relation = {
			# Save Feud attacker
			set_variable = { name = house_feud_attacker value = scope:house_feud_attacker }
			# Save Feud victim
			set_variable = { name = house_feud_victim value = scope:house_feud_victim }
			set_variable = { name = house_feud_house_1 value = scope:house_feud_attacker.house }
			set_variable = { name = house_feud_house_2 value = scope:house_feud_victim.house }
			# Save Feud starters
			set_variable = { name = house_feud_house_1_first_head value = scope:starter_house_head }
			set_variable = { name = house_feud_house_2_first_head value = scope:house_feud_rival }
			set_variable = { name = house_feud_house_1_score value = 0 }
			set_variable = { name = house_feud_house_2_score value = 0 }
			# Save start reason flavor
			set_variable = { name = house_feud_reason value = flag:$REASON$ }
			# Move starting score/save flavor if relevant
			if = {
				limit = { exists = var:house_feud_reason }
				switch = {
					trigger = var:house_feud_reason
					flag:head_killed = {
						change_variable = { name = house_feud_house_1_score add = house_feud_medium_counter_value }
					}
					flag:family_killed = {
						change_variable = { name = house_feud_house_1_score add = house_feud_medium_counter_value }
					}
					flag:head_cuckolded = {
						change_variable = { name = house_feud_house_1_score add = house_feud_minor_counter_value }
					}
					flag:family_cuckolded = {
						change_variable = { name = house_feud_house_1_score add = house_feud_minor_counter_value }
					}
					flag:competing_claim = {
						set_variable = { name = house_feud_title value = scope:house_feud_claim }
					}
					flag:head_tortured = {
						if = {
							limit = {
								scope:house_feud_victim = { has_character_flag = house_feud_blinding_flag }
							}
							set_variable = { name = house_feud_reason value = flag:head_blinded }
						}
						else_if = {
							limit = {
								scope:house_feud_victim = { has_character_flag = house_feud_castration_flag }
							}
							set_variable = { name = house_feud_reason value = flag:head_castrated }
						}
					}
					flag:family_tortured = {
						if = {
							limit = {
								scope:house_feud_victim = { has_character_flag = house_feud_blinding_flag }
							}
							set_variable = { name = house_feud_reason value = flag:family_blinded }
						}
						else_if = {
							limit = {
								scope:house_feud_victim = { has_character_flag = house_feud_castration_flag }
							}
							set_variable = { name = house_feud_reason value = flag:family_castrated }
						}
					}
					flag:head_shaved = {
						if = {
							limit = {
								scope:house_feud_victim = { has_character_flag = house_feud_shaving_flag }
							}
							set_variable = { name = house_feud_reason value = flag:head_shaved }
						}
					}
					flag:family_shaved = {
						if = {
							limit = {
								scope:house_feud_victim = { has_character_flag = house_feud_shaving_flag }
							}
							set_variable = { name = house_feud_reason value = flag:family_shaved }
						}
					}
					flag:head_cuckolded = {
						if = {
							limit = { NOT = { exists = scope:house_feud_spouse } }
							scope:house_feud_victim = { random_spouse = { save_scope_as = house_feud_spouse } }
						}
						set_variable = { name = house_feud_spouse value = scope:house_feud_spouse }
					}
					flag:family_broke_gw_betrothal = {
						if = {
							limit = { scope:starter_house_head = scope:house_feud_victim }
							set_variable = { name = house_feud_reason value = flag:head_broke_gw_betrothal }
						}
					}
				}
			}
			# Invalidate exit
			if = {
				limit = {
					NAND = {
						exists = var:house_feud_house_1
						exists = var:house_feud_house_2
						exists = var:house_feud_house_1_first_head
						exists = var:house_feud_house_2_first_head
						exists = var:house_feud_house_1_score
						exists = var:house_feud_house_2_score
						exists = var:house_feud_reason
					}
				}
				# Variable is missing! Ending story prematurely.
				debug_log = "House Feud invalidated"
				debug_log_scopes = yes
				end_story = yes
			}
			# Inform House Members feud has started
			every_relation_house = {
				every_house_member = {
					limit = { is_ai = no }
					# Explanatory Tooltips
					send_interface_message = {
						type = house_feud_begins_message
						left_icon = scope:starter_house_head
						right_icon = scope:house_feud_rival
						show_as_tooltip = {
							scope:starter_house_head = {
								#Show as tooltip does not require a reason
								if = {
									limit = { has_relation_nemesis = scope:house_feud_rival }
									set_relation_nemesis = scope:house_feud_rival
								}
								else = { set_relation_rival = scope:house_feud_rival }
							}
						}
					}
					# deprecated
					#trigger_event = {
					#	id = bp1_house_feud.0600
					#	days = 5
					#}
				}
			}
		}
		### MEMORY
		scope:starter_house_head ?= {
			create_character_memory = {
				type = house_feud_started_memory
				participants = {
					house_head = scope:house_feud_rival
					attacker = scope:house_feud_attacker
					victim = scope:house_feud_victim
				}
			}
			ordered_memory = {
				limit = {
					has_memory_type = house_feud_started_memory
					any_memory_participant = { this = scope:house_feud_rival }
				}
				order_by = memory_creation_date
				set_variable = {
					name = house_feud_reason
					value = scope:relation.var:house_feud_reason
				}
				if = {
					limit = { exists = scope:relation.var:house_feud_title }
					set_variable = {
						name = house_feud_title
						value = scope:relation.var:house_feud_title
					}
				}
				if = {
					limit = { exists = scope:relation.var:house_feud_spouse }
					set_variable = {
						name = house_feud_spouse
						value = scope:relation.var:house_feud_spouse
					}
				}
			}
		}
	}
}

### END EFFECTS ###

# End current Feud
#house_feud_end_story_effect = {
#	# Explanatory tooltip
#	custom_tooltip = house_feud_end_tt
#	# End Story Cycle
#	random_owned_story = {
#		limit = { story_type = story_cycle_house_feud }
#		end_story = yes
#	}
#}

# Clear up and set modifiers based on Feud score or fallback
#house_feud_end_modifier_effect = {
#	if = {
#		limit = {
#			NOT = { exists = scope:story }
#			exists = house.house_head
#			house.house_head = {
#				any_owned_story = { story_type = story_cycle_house_feud }
#			}
#		}
#		house.house_head = {
#			random_owned_story = {
#				limit = { story_type = story_cycle_house_feud }
#				save_scope_as = story
#			}
#		}
#	}
#	if = {
#		limit = { exists = scope:story }
#		scope:story = {
#			if = {
#				limit = { exists = var:house_feud_house.house_head }
#				var:house_feud_house.house_head = { save_scope_as = house_feud_rival }
#			}
#			if = {
#				limit = {
#					exists = scope:house_feud_rival
#					scope:house_feud_rival = { is_alive = yes }
#				}
#				story_owner = {
#					# Remove Nemesis when ending Feud if relevant
#					if = {
#						limit = { has_relation_nemesis = scope:house_feud_rival }
#						hidden_effect = { remove_relation_nemesis = scope:house_feud_rival }
#						set_relation_rival = {
#							target = scope:house_feud_rival
#							reason = rival_house_feud_no_longer_nemesis
#						}
#					}
#					# Otherwise remove Rival
#					else_if = {
#						limit = { has_relation_rival = scope:house_feud_rival }
#						remove_relation_rival = scope:house_feud_rival
#					}
#					house = {
#						every_house_member = {
#							limit = { is_ai = yes }
#							if = {
#								limit = { has_relation_nemesis = scope:house_feud_rival }
#								hidden_effect = { remove_relation_nemesis = scope:house_feud_rival }
#								set_relation_rival = {
#									target = scope:house_feud_rival
#									reason = rival_house_feud_no_longer_nemesis
#								}
#							}
#							# Otherwise remove Rival
#							else_if = {
#								limit = { has_relation_rival = scope:house_feud_rival }
#								remove_relation_rival = scope:house_feud_rival
#							}
#						}
#					}
#				}
#			}
#			if = {
#				limit = {
#					exists = var:house_feud_death_counter
#					exists = var:house_feud_kill_counter
#				}
#				# Reward modifiers based on score
#				# If losing badly, worst modifier
#				if = {
#					limit = { house_feud_balance_value <= -3 }
#					story_owner.house = {
#						add_house_modifier = {
#							modifier = house_feud_terrible_modifier
#							years = 25
#							desc = house_feud_terrible_modifier_custom_desc
#						}
#					}
#				}
#				# If losing, bad modifier
#				else_if = {
#					limit = { house_feud_balance_value < -0.5 }
#					story_owner.house = {
#						add_house_modifier = {
#							modifier = house_feud_bad_modifier
#							years = 25
#							desc = house_feud_bad_modifier_custom_desc
#						}
#					}
#				}
#				# If similar, average modifier
#				else_if = {
#					limit = {
#						house_feud_balance_value >= -0.5
#						house_feud_balance_value <= 0.5
#					}
#					story_owner.house = {
#						add_house_modifier = {
#							modifier = house_feud_even_modifier
#							years = 25
#							desc = house_feud_even_modifier_custom_desc
#						}
#					}
#				}
#				# If winning, decent modifier
#				else_if = {
#					limit = {
#						house_feud_balance_value > 0.5
#						house_feud_balance_value < 3
#					}
#					story_owner.house = {
#						add_house_modifier = {
#							modifier = house_feud_good_modifier
#							years = 25
#							desc = house_feud_good_modifier_custom_desc
#						}
#					}
#				}
#				# If winning alot, good modifier
#				else_if = {
#					limit = { house_feud_balance_value >= 3 }
#					story_owner.house = {
#						add_house_modifier = {
#							modifier = house_feud_excellent_modifier
#							years = 25
#							desc = house_feud_excellent_modifier_custom_desc
#						}
#					}
#				}
#				story_owner.house = {
#					custom_tooltip = house_reward_modifier_tt
#				}
#			}
#			# Give good modifier as fallback or if Feud targets were wiped out
#			else = {
#				story_owner.house = {
#					add_house_modifier = {
#						modifier = house_feud_excellent_modifier
#						years = 25
#						desc = house_feud_excellent_modifier_custom_desc
#					}
#				}
#			}
#			# Remove ongoing modifier
#			story_owner.house = { remove_house_modifier = house_feud_story_modifier }
#		}
#	}
#	custom_tooltip = house_feud_cooldown_tt
#}

# Shared stress effect for Vengeful characters
house_feud_vengeful_stress_effect = {
	stress_impact = {
		vengeful = major_stress_impact_gain
		arbitrary = medium_stress_impact_gain
		wrathful = minor_stress_impact_gain
		brave = minor_stress_impact_gain
		ambitious = minor_stress_impact_gain
		arrogant = minor_stress_impact_gain
	}
}

house_feud_forgiving_stress_effect = {
	stress_impact = {
		forgiving = major_stress_impact_gain
		just = medium_stress_impact_gain
		calm = minor_stress_impact_gain
		craven = minor_stress_impact_gain
		content = minor_stress_impact_gain
		humble = minor_stress_impact_gain
	}
}


### SCOPE EFFECTS ###

# Save attacker and rival scopes for reference
house_feud_save_head_and_attacker_effect = {
	house.house_head = { save_scope_as = house_feud_rival }
	save_scope_as = house_feud_attacker
}

### MESSAGE EFFECTS ###

# Send Feud continued message to player House members on inheritance
#house_feud_send_continues_message_effect = {
#	# Flag to block starting more than one Feud per lifetime in most cases (House Head cuckoldry and torture are exceptions)
#	add_character_flag = had_house_feud_story
#	house = {
#		every_house_member = {
#			limit = { is_ai = no }
#			hidden_effect = {
#				send_interface_message = {
#					type = house_feud_continues_message
#					left_icon = root
#					right_icon = scope:house_feud_rival
#					title = msg_house_feud_continues
#					desc = msg_house_feud_continues_desc
#				}
#			}
#		}
#	}
#}

### ACTION EFFECTS ###

# Feud cuckoldry score and event effects
house_feud_lover_exposure_effect = {
	hidden_effect = {
		if = {
			limit = {
				has_bp1_dlc_trigger = yes
				is_married = yes
				any_spouse = {
					exists = house.house_head
					house.house_head ?= {
						valid_for_feud_events_with_target_trigger = { TARGET = scope:sex_partner }
						NOT = {
							accepts_adultery_without_penalty_trigger = yes
						}
					}
				}
			}
			# Save cheating spouse scope for reference
			save_scope_as = house_feud_spouse
			# Save cuckolder's scopes for reference
			scope:sex_partner = { house_feud_save_head_and_attacker_effect = yes }
			every_spouse = {
				limit = {
					house.house_head ?= {
						valid_for_feud_events_with_target_trigger = { TARGET = scope:sex_partner }
					}
				}
				# Save cuckolded spouse for reference
				save_scope_as = house_feud_victim
				house.house_head = {
					# Chance for House Head to have option to start Feud
					random = {
						chance = 75
						modifier = {
							add = 25
							has_trait = vengeful
						}
						modifier = {
							add = -25
							has_trait = forgiving
						}
						modifier = {
							add = -25
							has_any_bad_relationship_with_character_trigger = { CHARACTER = scope:sex_partner }
						}
						modifier = { # LOTR
							add = 25
							opposite_alignment = { TARGET = scope:killer }
						}
						# House Head version
						if = {
							limit = { is_spouse_of = scope:house_feud_spouse }
							trigger_event = {
								id = bp1_house_feud.0013
								days = { 5 15 }
							}
						}
						# Close family version
						else = {
							trigger_event = {
								id = bp1_house_feud.0014
								days = { 5 15 }
							}
						}
					}
				}
			}
		}
		# Score and message effects
		if = {
			limit = {
				exists = scope:sex_partner.house.house_head
				any_spouse = {
					save_temporary_scope_as = house_feud_cuckolded_temp_1
					scope:sex_partner = {
						house_has_feud_relation_with_trigger = { TARGET = scope:house_feud_cuckolded_temp_1 }
					}
					save_temporary_scope_as = house_feud_cuckolded_temp_2
				}
			}
			scope:house_feud_cuckolded_temp_2 = { save_scope_as = house_feud_cuckolded }
			scope:sex_partner.house = {
				change_house_relation_feud_score_effect = {
					TARGET = scope:house_feud_cuckolded.house
					REASON = cuckolded
					VALUE = house_feud_minor_counter_value
				}
				# If original Feud reason was cuckolding, fire revenge event for House Head
				if = {
					limit = {
						any_house_relation = {
							has_house_relation_level = feud
							any_relation_house = {
								NOT = { this = scope:sex_partner.house }
								this = scope:house_feud_cuckolded.house
							}
							OR = {
								var:house_feud_reason ?= flag:head_cuckolded
								var:house_feud_reason ?= flag:family_cuckolded
							}
							var:house_feud_attacker ?= scope:house_feud_cuckolded
							NOT = { exists = var:feud_avenged }
						}
					}
					house_head = {
						trigger_event = { id = bp1_house_feud.7003 days = 15 }
					}
				}
			}
		}
	}
}

# Feud torture score and event effects
house_feud_torture_event_effect = {
	hidden_effect = {
		# Tortured belongs to torturer's Houses's Feud target House
		scope:actor.house ?= {
			change_house_relation_feud_score_effect = {
				TARGET = scope:recipient.house
				REASON = torture
				VALUE = house_feud_minor_counter_value
			}
			# If originial Feud reason was Torture, fire revenge event for House Head
			if = {
				limit = {
					any_house_relation = {
						has_house_relation_level = feud
						OR = {
							var:house_feud_victim.house ?= scope:actor.house
							var:house_feud_reason ?= flag:head_tortured
							var:house_feud_reason ?= flag:family_tortured
							var:house_feud_reason = flag:head_shaved #LotR
							var:house_feud_reason = flag:family_shaved #LotR
						}
						var:house_feud_attacker ?= scope:recipient
						NOT = { exists = var:feud_avenged }
					}
				}
				house_head = {
					trigger_event = { id = bp1_house_feud.7002 days = 15 }
				}
			}
		}
		scope:recipient.house.house_head ?= {
			# Chance for tortured House to start a Feud if eligible
			if = {
				limit = {
					valid_for_feud_events_with_target_trigger = { TARGET = scope:actor }
				}
				random_list = {
					# Give House Head option to start Feud
					25 = {
						modifier = {
							add = 25
							has_trait = vengeful
						}
						modifier = {
							add = -25
							has_trait = forgiving
						}
						scope:actor = { house_feud_save_head_and_attacker_effect = yes }
						scope:recipient = {
							save_scope_as = house_feud_victim
							house.house_head = {
								if = {
									limit = { this = scope:house_feud_victim }
									trigger_event = {
										id = bp1_house_feud.0010 # Version for tortured House Heads
										days = { 5 15 }
									}
								}
								else = {
									trigger_event = {
										id = bp1_house_feud.0011 # Version for tortured close family
										days = { 5 15 }
									}
								}
							}
						}
					}
					# Clean up tortured's flags if no Feud started
					50 = {
						scope:recipient = {
							if = {
								limit = { has_character_flag = house_feud_castration_flag }
								remove_character_flag = house_feud_castration_flag
							}
							else_if = {
								limit = { has_character_flag = house_feud_blinding_flag }
								remove_character_flag = house_feud_blinding_flag
							}
							else_if = {
								limit = { has_character_flag = house_feud_disfigured_flag }
								remove_character_flag = house_feud_disfigured_flag
							}
						}
					}
				}
			}
		}
	}
}

set_war_memory_casus_belli_effect = {
	save_scope_as = memory
	scope:war = {
		casus_belli = {
			if = {
				limit = {
					any_target_title = { }
				}
				ordered_target_title = {
					order_by = tier
					save_scope_as = war_target
				}
				scope:memory = {
					set_variable = { name = war_title value = scope:war_target }
				}
			}
			if = {
				limit = { exists = claimant }
				claimant = { save_scope_as = war_claimant }
				scope:memory = {
					set_variable = { name = war_claimant value = scope:war_claimant }
				}
			}
		}
		scope:memory = {
			set_variable = {
				name = war_attacker
				value = scope:war.primary_attacker
			}
		}
		if = { # claim
			limit = {
				OR = {
					using_cb = claim_cb
					using_cb = claimant_faction_war
				}
			}
			scope:memory = {
				set_variable = { name = war_cb value = flag:war_memory_cb_claim }
			}
		}	
		else_if = { # conquest
			limit = {
				OR = {
					using_cb = county_conquest_cb
					using_cb = duchy_conquest_cb
					using_cb = county_struggle_cb
					# using_cb = fp2_mediterranean_conquest_cb #LotR
					using_cb = nomadic_conquest_cb
					using_cb = nomadic_conquest_duchy_cb
					using_cb = domination_cb
					using_cb = de_jure_cb_nomadic
					using_cb = japan_install_bloc_member_cb
					using_cb = japan_soryo_conquest_county_landless_cb
					using_cb = japan_soryo_conquest_county_cb
				}
			}
			scope:memory = {
				set_variable = { name = war_cb value = flag:war_memory_cb_conquest }
			}
		}
		else_if = { # holy
			limit = {
				OR = {
					using_cb = minor_religious_war
					using_cb = religious_war
					using_cb = major_religious_war
				}
			}
			scope:memory = {
				set_variable = { name = war_cb value = flag:war_memory_cb_holy_war }
				set_variable = { name = war_faith value = scope:war.primary_defender.faith }
				set_variable = { name = war_faith_attacker value = scope:war.primary_attacker.faith }
			}
		}
		else_if = { # de jure
			limit = {
				OR = {
					using_cb = de_jure_cb
					using_cb = individual_county_de_jure_cb
					using_cb = individual_duchy_de_jure_cb
					using_cb = japan_imperial_reconquest_cb
				}
			}
			scope:memory = {
				set_variable = { name = war_cb value = flag:war_memory_cb_de_jure }
				scope:war_target = {
					ordered_this_title_or_de_jure_above = {
						limit = { holder.top_liege = scope:war.primary_attacker }
						order_by = tier
						save_scope_as = war_liege
					}
				}
				if = {
					limit = { exists = scope:war_liege }
					set_variable = { name = war_liege value = scope:war_liege }
				}
			}
		}
		else_if = { # invasion
			limit = {
				OR = {
					using_cb = mpo_nomad_invasion_cb
					using_cb = invasion_war
					using_cb = clan_invasion_war
					# using_cb = mongol_invasion_war #LotR
					# using_cb = mongol_realm_invasion_war #LotR
					using_cb = ep3_laamp_adventurer_county_invasion
					using_cb = ep3_laamp_adventurer_duchy_invasion
					using_cb = ep3_laamp_adventurer_kingdom_invasion
					using_cb = ep3_laamp_adventurer_empire_invasion
					using_cb = mpo_gok_onslaught_cb
					using_cb = japan_imperial_expansion_cb
				}
			}
			scope:memory = {
				set_variable = { name = war_cb value = flag:war_memory_cb_invasion }
			}
		}
		else_if = { # ghw
			limit = {
				OR = {
					using_cb = undirected_great_holy_war
					using_cb = directed_great_holy_war
				}
			}
			scope:memory = {
				set_variable = { name = war_cb value = flag:war_memory_cb_ghw }
				set_variable = { name = war_faith value = scope:war.primary_defender.faith }
				set_variable = { name = war_faith_attacker value = scope:war.primary_attacker.faith }
			}
		}
		else_if = { # independence
			limit = {
				OR = {
					using_cb = independence_war
					using_cb = independence_faction_war
					using_cb = tributary_independence_war
				}
			}
			scope:memory = {
				set_variable = { name = war_cb value = flag:war_memory_cb_independence }
			}
		}
		else_if = { # artifact
			limit = {
				OR = {
					using_cb = artifact_war
					using_cb = reclaim_relic_artifact_war
				}
			}
			scope:memory = {
				set_variable = { name = war_cb value = flag:war_memory_cb_artifact }
			}
		}
		else_if = { # populist
			limit = { using_cb = populist_war }
			scope:memory = {
				set_variable = { name = war_cb value = flag:war_memory_cb_populist }
				set_variable = { name = war_faith value = scope:war.primary_defender.faith }
				set_variable = { name = war_culture value = scope:war.primary_defender.culture }
			}
		}
		else_if = { # subjugation
			limit = {
				OR = {
					using_cb = tribal_subjugation_cb
					using_cb = make_tributary_cb
					using_cb = retaliation_cb
				}
			}
			scope:memory = {
				set_variable = { name = war_cb value = flag:war_memory_cb_subjugation }
			}
		}
		else_if = { # border
			limit = {
				OR = {
					# using_cb = fp2_border_raid #LotR
					using_cb = sovereignty_cb
				}
			}
			scope:memory = {
				set_variable = { name = war_cb value = flag:war_memory_cb_border }
			}
		}
		else_if = { # government
			limit = {
				OR = {
					using_cb = japan_demand_administrative_cb
					using_cb = japan_refused_ritsuryo_cb
					using_cb = japan_establish_soryo_administration_cb
				}
			}
			scope:memory = {
				set_variable = { name = war_cb value = flag:war_memory_cb_government }
				set_variable = { name = war_gov value = scope:war.primary_attacker.government_type }
			}
		}
		else_if = { # bloc
			limit = {
				OR = {
					using_cb = japan_bloc_war_cb
					using_cb = japan_install_bloc_member_cb
				}
			}
			scope:memory = {
				set_variable = { name = war_cb value = flag:war_memory_cb_bloc }
				set_variable = { name = war_bloc value = scope:war.primary_attacker.house.house_confederation }
			}
		}
		else = {
			switch = {
				trigger = using_cb
				liberty_faction_war = { # liberty
					scope:memory = {
						set_variable = { name = war_cb value = flag:war_memory_cb_liberty }
					}
				}
				depose_war = { # depose
					scope:memory = {
						set_variable = { name = war_cb value = flag:war_memory_cb_depose }
					}
				}
				refused_liege_demand_war = { # tyranny
					scope:memory = {
						set_variable = { name = war_cb value = flag:war_memory_cb_tyranny }
					}
				}
				nation_fracturing_faction_war = { # fracture
					scope:memory = {
						set_variable = { name = war_cb value = flag:war_memory_cb_fracture }
					}
				}
				ducal_conquest_cb = { # ducal conquest
					scope:memory = {
						set_variable = { name = war_cb value = flag:war_memory_cb_ducal_conquest }
					}
				}
				# imperial_reconquest_cb = { # imperial reconquest #LotR
				# 	scope:memory = {
				# 		set_variable = { name = war_cb value = flag:war_memory_cb_imperial_reconquest }
				# 	}
				# }
				# dismantle_holy_pretender_cb = { # holy pretender #LotR
				# 	scope:memory = {
				# 		set_variable = { name = war_cb value = flag:war_memory_cb_holy_pretender }
				# 	}
				# }
				# dismantle_byz_pretender_cb = { # byz pretender #LotR
				# 	scope:memory = {
				# 		set_variable = { name = war_cb value = flag:war_memory_cb_byz_pretender }
				# 	}
				# }
				excommunication_war = { # excommunicate
					scope:memory = {
						set_variable = { name = war_cb value = flag:war_memory_cb_excommunicate }
					}
				}
				flowery_war_cb = { # flower
					scope:memory = {
						set_variable = { name = war_cb value = flag:war_memory_cb_flower }
					}
				}
				vassalization_cb = {
					scope:memory = {
						set_variable = { name = war_cb value = flag:war_memory_cb_vassalization }
					}
				}				
				fp1_varangian_adventurer_conquest = {
					scope:memory = {
						set_variable = { name = war_cb value = flag:war_memory_cb_varangian }
					}
				}
				fp1_scandi_adventurer_conquest = {
					scope:memory = {
						set_variable = { name = war_cb value = flag:war_memory_cb_varangian }
					}
				}
				# fp2_border_raid = { #LotR
				# 	scope:memory = {
				# 		set_variable = { name = war_cb value = flag:war_memory_cb_border }
				# 	}
				# }
				# fp2_expel_interloper = { #LotR
				# 	scope:memory = {
				# 		set_variable = { name = war_cb value = flag:war_memory_cb_expel }
				# 	}
				# }
				diarch_vassalisation_cb = {
					scope:memory = {
						set_variable = { name = war_cb value = flag:war_memory_cb_vassalization }
					}
				}
				remove_regent_cb = {
					scope:memory = {
						set_variable = { name = war_cb value = flag:war_memory_cb_regent }
					}
				}
				# norman_conquest_cb = { #LotR
				# 	scope:memory = {
				# 		set_variable = { name = war_cb value = flag:war_memory_cb_claim }
				# 	}
				# }
				# norwegian_invasion_cb = { #LotR
				# 	scope:memory = {
				# 		set_variable = { name = war_cb value = flag:war_memory_cb_claim }
				# 	}
				# }
				# hungarian_migration_cb = { #LotR
				# 	scope:memory = {
				# 		set_variable = { name = war_cb value = flag:war_memory_cb_invasion }
				# 	}
				# }
				# sons_of_lothbrok_invasion_cb = { #LotR
				# 	scope:memory = {
				# 		set_variable = { name = war_cb value = flag:war_memory_cb_invasion }
				# 	}
				# }
				peasant_war = {
					scope:memory = {
						set_variable = { name = war_cb value = flag:war_memory_cb_peasant }
					}
				}
				replace_ceremonial_regent_faction_war = {
					scope:memory = {
						set_variable = { name = war_cb value = flag:war_memory_cb_depose }
					}
				}
				fallback = {
					scope:memory = {
						set_variable = { name = war_cb value = flag:war_memory_cb_fallback }
					}
				}
			}
		}
	}
	if = { # Error culler
		limit = {
			exists = scope:memory.var:war_cb
			OR = {
				scope:memory.var:war_cb = flag:war_memory_cb_fallback
				scope:memory.var:war_cb = flag:war_memory_cb_holy_war
				scope:memory.var:war_cb = flag:war_memory_cb_imperial_reconquest
				scope:memory.var:war_cb = flag:war_memory_cb_conquest
				scope:memory.var:war_cb = flag:war_memory_cb_claim
				scope:memory.var:war_cb = flag:war_memory_cb_de_jure
				scope:memory.var:war_cb = flag:war_memory_cb_ducal_conquest
				scope:memory.var:war_cb = flag:war_memory_cb_holy_pretender
				scope:memory.var:war_cb = flag:war_memory_cb_byz_pretender
				scope:memory.var:war_cb = flag:war_memory_cb_invasion
				scope:memory.var:war_cb = flag:war_memory_cb_independence
				scope:memory.var:war_cb = flag:war_memory_cb_liberty
				scope:memory.var:war_cb = flag:war_memory_cb_depose
				scope:memory.var:war_cb = flag:war_memory_cb_fracture
				scope:memory.var:war_cb = flag:war_memory_cb_excommunicate
				scope:memory.var:war_cb = flag:war_memory_cb_flower
				scope:memory.var:war_cb = flag:war_memory_cb_ghw
				scope:memory.var:war_cb = flag:war_memory_cb_artifact
				scope:memory.var:war_cb = flag:war_memory_cb_subjugation
				scope:memory.var:war_cb = flag:war_memory_cb_vassalization
				scope:memory.var:war_cb = flag:war_memory_cb_varangian
				scope:memory.var:war_cb = flag:war_memory_cb_border
				scope:memory.var:war_cb = flag:war_memory_cb_expel
				scope:memory.var:war_cb = flag:war_memory_cb_regent
				scope:memory.var:war_cb = flag:war_memory_cb_tyranny
				scope:memory.var:war_cb = flag:war_memory_cb_government
				scope:memory.var:war_cb = flag:war_memory_cb_bloc
			}
		}
	}
}

copy_war_memory_casus_belli_effect = {
	if = {
		limit = { exists = $MEMORY$.var:war_cb }
		set_variable = {
			name = war_cb
			value = $MEMORY$.var:war_cb
		}
		if = {
			limit = { exists = $MEMORY$.var:war_attacker }
			set_variable = {
				name = war_attacker
				value = $MEMORY$.var:war_attacker
			}
		}
		if = {
			limit = { exists = $MEMORY$.var:war_title }
			set_variable = {
				name = war_title
				value = $MEMORY$.var:war_title
			}
		}
		if = {
			limit = { exists = $MEMORY$.var:war_claimant }
			set_variable = {
				name = war_claimant
				value = $MEMORY$.var:war_claimant
			}
		}
		if = {
			limit = { exists = $MEMORY$.var:war_faith }
			set_variable = {
				name = war_faith
				value = $MEMORY$.var:war_faith
			}
		}
		if = {
			limit = { exists = $MEMORY$.var:war_culture }
			set_variable = {
				name = war_culture
				value = $MEMORY$.var:war_culture
			}
		}
		if = {
			limit = { exists = $MEMORY$.var:war_faith_attacker }
			set_variable = {
				name = war_faith_attacker
				value = $MEMORY$.var:war_faith_attacker
			}
		}
		if = {
			limit = { exists = $MEMORY$.var:war_liege }
			set_variable = {
				name = war_liege
				value = $MEMORY$.var:war_liege
			}
		}
	}
	else = {
		set_variable = {
			name = war_cb
			value = flag:war_memory_cb_fallback
		}
	}
}

set_war_over_memory_casus_belli_effect = {
	ordered_memory = {
		limit = {
			has_memory_type = $STANCE$_war
			any_memory_participant = {
				OR = {
					this = scope:$OTHER$
					this = { is_vassal_of = scope:$OTHER$ }
				}
			}
		}
		order_by = memory_creation_date 
		save_scope_as = war_memory
	}
	ordered_memory = {
		limit = {
			has_memory_type = war_$OUTCOME$
			any_memory_participant = { this = scope:$SELF$ }
			any_memory_participant = { this = scope:$OTHER$ }		
		}
		order_by = memory_creation_date 
		copy_war_memory_casus_belli_effect = { MEMORY = scope:war_memory }
	}
}

house_feud_murder_effect = {
	if = {
		limit = {
			has_bp1_dlc_trigger = yes
			exists = $VICTIM$.house.house_head
			exists = $MURDERER$.house.house_head
		}
		$VICTIM$ = { save_scope_as = house_feud_victim }
		$MURDERER$ = { save_scope_as = house_feud_attacker }
		scope:house_feud_victim = {
			save_ongoing_house_relation_effect = { TARGET = scope:house_feud_attacker }
		}
		# Notifications
		# Inform victim house that they have lost score
		if = {
			limit = {
				# Victim's House is targeted by killer's House
				scope:house_feud_victim = {
					house_has_feud_relation_with_trigger = { TARGET = scope:house_feud_attacker }
				}
			}
			scope:house_feud_attacker.house = {
				change_house_relation_feud_score_effect = {
					TARGET = scope:house_feud_victim.house
					REASON = kill
					VALUE = house_feud_medium_counter_value
				}
			}
			scope:relation ?= {
				if = {
					limit = {
						scope:house_feud_attacker.house = var:house_feud_house_1
					}
					set_variable = {
						name = house_feud_house_1_recent_kill
						value = scope:house_feud_victim
						months = 6
					}
				}
				else = {
					set_variable = {
						name = house_feud_house_2_recent_kill
						value = scope:house_feud_victim
						months = 6
					}
				}
			}
		}
		# Events
		# Fire Feud start event for victim house
		if = {
			limit = {
				scope:house_feud_victim.house.house_head ?= {
					NOT = {
						has_any_bad_relationship_with_character_trigger = { CHARACTER = scope:house_feud_victim }
					}
					valid_for_feud_events_with_target_trigger = { TARGET = scope:house_feud_attacker }
				}
			}
			scope:house_feud_attacker = { house_feud_save_head_and_attacker_effect = yes }
			scope:house_feud_victim.house.house_head = {
				random = {
					chance = 25
					modifier = {
						add = 25
						has_trait = vengeful
					}
					modifier = {
						add = -25
						has_trait = forgiving
					}
					modifier = {
						add = 25
						has_any_bad_relationship_with_character_trigger = { CHARACTER = scope:house_feud_attacker }
					}
					trigger_event = {
						id = bp1_house_feud.0005
						days = { 5 15 }
					}
				}
			}
		}
		# Fire Feud revenge event for killer house
		scope:house_feud_attacker.house = {
			if = {
				limit = {
					any_house_relation = {
						has_house_relation_level = feud
						any_relation_house = {
							NOT = { this = scope:house_feud_attacker.house }
							this = scope:house_feud_victim.house
						}
						OR = {
							var:house_feud_reason ?= flag:head_killed
							var:house_feud_reason ?= flag:family_killed
						}
						var:house_feud_attacker ?= scope:house_feud_victim
						NOT = { exists = var:feud_avenged }
					}
				}
				house_head = {
					trigger_event = { id = bp1_house_feud.7001 days = 15 }
				}
			}
		}
	}
}
