NAI = {
	SHORT_TASK_TICK = {									# Number of days between recalculating short  tasks (per tier)
		7
		30
		14
		7
		7
		7
	}
	
	MEDIUM_TASK_TICK = {								# Number of days between recalculating medium tasks (per tier)
		30
		180
		60
		30
		30
		30
	}
	
	LONG_TASK_TICK = {									# Number of days between recalculating long tasks (per tier)
		60
		360
		180
		60
		60
		60
	}
	
	RARE_TASK_TICK = {									# Number of days between recalculating rare tasks (per tier)
		180
		720
		360
		180
		180
		180
	}

	STRATEGY_TASK_TICK = {									# Number of days between recalculating strategy tasks (per tier)
		180
		720
		360
		180
		180
		180
	}

	TITLE_AND_VASSAL_GRANT_TICK = {						# Number of days between checking title and vassal grants (per tier). If a grant happens, it'll always get rechecked on the next day
		720
		720
		720
		90
		90
		90
	}

	REVOKE_TITLE_TICK = {						# Number of days between checking title revocations (per tier). If a revocation happens, it'll always get rechecked on the next day. Imprisoning a vassal will also cause a check on the next day
		720
		720
		720
		360
		360
		360
	}

	# Number of days between checking tax collector ticks per tier
	TAX_COLLECTOR_TASK_TICK = {
		1800  # Unlanded has no vassals
		1800 # Barons have no vassals
		1100
		720
		120
		60
	}

    ### Brief: MINIMUM_TASKS_IN_TICK ( int32 )
    # The minimum number of tasks that need to be processed in each
    # tick.
    #
    MINIMUM_TASKS_IN_TICK = 128

    ### Brief: MAX_TASKS_IN_TICK ( int32 )
    # The cap on tasks processed per tick. If tick frequency would
    # suggest processing more, this cap is ignored.
    #
    MAX_TASKS_IN_TICK = 192

    ### Brief: MAX_TICK_STALENESS ( int32 )
    # Maximum tick delay allowed for better load-balancing.
    #
    MAX_TICK_STALENESS = 8

	BUDGET_CATEGORY = {									# The last category is the main category
		0.0												# Reserved (only used for certain types of characters, like the Pope)
		0.0												# War chest; has its own logic
		0.20											# LongTerm
		0.80											# ShortTerm
	}
	
	BUDGET_CATEGORY_MAX = {								# Over max it will try to redistribute overflow to other category
		-1
		-1
		5000
		5000
	}
	
	BUDGET_CATEGORY_SHORT_TERM_MIN = {					# Under this amount of short term gold the AI will be hesitant to spend/save on other categories (per tier)
		25
		25
		200
		200
		400
		400
	}
	

	### Brief: MIN_RESERVED_GOLD_SPIRITUAL_HEAD_OF_FAITH ( int32 )
	# Character will avoid actively using gold if under this value
	#
	MIN_RESERVED_GOLD_SPIRITUAL_HEAD_OF_FAITH = 750

	### Brief: MIN_RESERVED_GOLD_HOLY_ORDER ( int32 )
	# Character will avoid actively using gold if under this value
	#
	MIN_RESERVED_GOLD_HOLY_ORDER = 500					

    ### Brief: MIN_WAR_CHEST ( Array of int32 )
	# The desired war chest will always be at least this much money, by
	# tier
	#
	MIN_WAR_CHEST = {									
		25
		25
		50
		100
		200
		300
	}


    ### Brief: MONTHS_OF_MAINTENANCE_IN_WAR_CHEST ( Fixed Point )
	# The AI will want this many months of max maintenance in their war
	# chest, if that's more than what MIN_WAR_CHEST says
	#
	MONTHS_OF_MAINTENANCE_IN_WAR_CHEST = 18

    ### Brief: PERCENTAGE_INTO_WAR_CHEST ( Fixed Point )
	# When the war chest hasn't been filled, the AI will put this much
	# of the money it earns into the war chest (reserved gold still
	# gets filled first)
	#
	PERCENTAGE_INTO_WAR_CHEST = 0.6

    ### Brief: BUILDING_MIN_SCORE_COMPARED_TO_BEST ( Fixed Point )
	# Any potential building with a score lower than this ratio of the
	# best available building (even if the AI can't afford it right
	# now) will be discarded
	#
	BUILDING_MIN_SCORE_COMPARED_TO_BEST = 0.8
	
    ### Brief: GOALS_PER_TYPE ( Array of int32 )
	# Number goals per type (per tier)
	#
	GOALS_PER_TYPE = {									
		0
		0
		1
		2
		3
		3
	}

    ### Brief: MEN_AT_ARMS_REALM_SIZE_FOR_COST_EFFECTIVENESS_START ( int32 )
    # At realm sizes of this and below, men-at-arms quality is based on 
    # stat points compared to cost.
    #
    MEN_AT_ARMS_REALM_SIZE_FOR_COST_EFFECTIVENESS_START = 5

    ### Brief: MEN_AT_ARMS_REALM_SIZE_FOR_COST_EFFECTIVENESS_END ( int32 )
    # At realm sizes after this, men-at-arms quality is completely 
    # unaffected by cost. Between the two values, we interpolate between 
    # the unmodified and modified quality.
    #
    MEN_AT_ARMS_REALM_SIZE_FOR_COST_EFFECTIVENESS_END = 50

    ### Brief: MEN_AT_ARMS_STATIONED_MODIFIER_SCORE_MULTIPLIER ( Array of Fixed Point )
    # How much the AI values each regiment stat type (size, siege, 
    # damage, toughness, pursuit, screen) being improved by being
    # stationed in a province so it can decide which stat is the most
    # important to improve when picking where to station its best
    # men-at-arms.
    #
    MEN_AT_ARMS_STATIONED_MODIFIER_SCORE_MULTIPLIER = { 0 0 2 1.5 1 1 }

    ### Brief: GOAL_MIN_PROGRESS_TO_START ( Fixed Point )
    # Resources needed to be able to add a goal.
    #
    GOAL_MIN_PROGRESS_TO_START = 0.2

    ### Brief: GOAL_CREATE_TITLE_TIER_SCORE ( int32 )
    # Multiplied by tier * tier for balancing purposes, with 100 as a 
    # "normal" score. This puts a de jure duchy at 135.
    #
    GOAL_CREATE_TITLE_TIER_SCORE = 10

    ### Brief: GOAL_CREATE_TITLE_DE_JURE_MULTIPLIER ( int32 )
    # Multiplied if the title is de jure under the character.
    #
    GOAL_CREATE_TITLE_DE_JURE_MULTIPLIER = 2

    ### Brief: GOAL_CREATE_TITLE_COUNT_OVER_DOMAIN_LIMIT_MULTIPLIER ( int32 )
    # Multiplied if count and over domain limit.
    #
    GOAL_CREATE_TITLE_COUNT_OVER_DOMAIN_LIMIT_MULTIPLIER = 10

    ### Brief: CHARACTER_INTERACTION_DEFAULT_MIN_REPLY_DAYS ( int32 )
    # The AI will wait at least this many days before replying to a 
    # character interaction; the interaction can override this value.
    #
    CHARACTER_INTERACTION_DEFAULT_MIN_REPLY_DAYS = 3

    ### Brief: CHARACTER_INTERACTION_DEFAULT_MAX_REPLY_DAYS ( int32 )
    # The AI will wait at most this many days before replying to a 
    # character interaction; the interaction can override this value.
    #
    CHARACTER_INTERACTION_DEFAULT_MAX_REPLY_DAYS = 10

    ### Brief: BETROTHAL_MIN_AGE ( int32 )
    # The AI will not betroth nor seek betrothals with characters 
    # under this age.
    #
    BETROTHAL_MIN_AGE = 12

    ### Brief: MARRIAGE_FOCUS_MIN_AGE ( int32 )
    # Under this age, the AI will less often check for betrothals 
    # or marriages.
    #
    MARRIAGE_FOCUS_MIN_AGE = 20

    ### Brief: MARRIAGE_MALE_DESPERATION_AGE ( int32 )
    # Over this age, the AI will consider less enticing marriages.
    #
    MARRIAGE_MALE_DESPERATION_AGE = 25

    ### Brief: MARRIAGE_FEMALE_DESPERATION_AGE ( int32 )
    # Over this age, the AI will consider less enticing marriages.
    #
    MARRIAGE_FEMALE_DESPERATION_AGE = 25

    ### Brief: MARRIAGE_DESPERATION_AGE_MULTIPLIER ( int32 )
    # Multiplied with age minus desperation age.
    #
    MARRIAGE_DESPERATION_AGE_MULTIPLIER = 50

    ### Brief: MARRIAGE_NO_PRESTIGE_LOSS_BONUS ( int32 )
    # If a marriage causes no prestige loss, a bit of score is added.
    #
    MARRIAGE_NO_PRESTIGE_LOSS_BONUS = 50

    ### Brief: MARRIAGE_OWNER_IS_MATCHMAKER ( bool )
    # Indicates if we can simply check the "matchmaker" link rather
    # than using the interaction's redirect effect, allowing for better
    # AI performance.
    #
    MARRIAGE_OWNER_IS_MATCHMAKER = yes
	
	### Brief: MEN_AT_ARMS_STATIONED_MODIFIER_SCORE_MULTIPLIER ( Array of int32 )
	# Number of courts that are searched for spouse candidates, per
	# tier.
	#
	MAX_NUMBER_OF_COURTS_TO_SEARCH_FOR_SPOUSES = {		
		0
		0
		8
		16
		32
		32
	}
	
	### Brief: MEN_AT_ARMS_STATIONED_MODIFIER_SCORE_MULTIPLIER ( Array of int32 )
	# Number of spouse candidates before the search is aborted, per
	# tier.
	#
	MAX_NUMBER_OF_SPOUSE_CANDIDATES = {					
		0
		0
		4
		8
		16
		32
	}

    ### Brief: SPOUSE_SCORE_ALLIANCES_WANTED ( int32 )
    # Over this number, new alliances through marriage will not 
    # impact spouse score unless they are of a higher tier than the 
    # current highest tier alliance.
    #
    SPOUSE_SCORE_ALLIANCES_WANTED = 2

    ### Brief: SPOUSE_SCORE_EXISTING_ALLIANCE_DIVIDER ( Fixed Point )
    # If already allied, divide the alliance score by this.
    #
    SPOUSE_SCORE_EXISTING_ALLIANCE_DIVIDER = 1.5

    ### Brief: SPOUSE_SCORE_HIGHER_TIER_ALLIANCE ( int32 )
    # Score if the marriage yields an alliance with a higher-tier 
    # character.
    #
    SPOUSE_SCORE_HIGHER_TIER_ALLIANCE = 700

    ### Brief: SPOUSE_SCORE_SAME_TIER_ALLIANCE ( int32 )
    # Score if the marriage yields an alliance with a same-tier 
    # character.
    #
    SPOUSE_SCORE_SAME_TIER_ALLIANCE = 250

    ### Brief: SPOUSE_SCORE_LOWER_TIER_ALLIANCE ( int32 )
    # Score if the marriage yields an alliance with a lower-tier 
    # character.
    #
    SPOUSE_SCORE_LOWER_TIER_ALLIANCE = 100

    ### Brief: SPOUSE_SCORE_MALE_AGE_PENALTY_AGE ( int32 )
    # Over this age, a male spouse score penalty is applied.
    #
    SPOUSE_SCORE_MALE_AGE_PENALTY_AGE = 50

    ### Brief: SPOUSE_SCORE_FEMALE_AGE_PENALTY_AGE ( int32 )
    # Over this age, a female spouse score penalty is applied.
    #
    SPOUSE_SCORE_FEMALE_AGE_PENALTY_AGE = 30

    ### Brief: SPOUSE_SCORE_MALE_AGE_PENALTY_MULTIPLIER ( int32 )
    # Multiplied with the male spouse's age above 
    # SPOUSE_SCORE_MALE_AGE_PENALTY_AGE.
    #
    SPOUSE_SCORE_MALE_AGE_PENALTY_MULTIPLIER = 10

    ### Brief: SPOUSE_SCORE_FEMALE_AGE_PENALTY_MULTIPLIER ( int32 )
    # Multiplied with the female spouse's age above 
    # SPOUSE_SCORE_FEMALE_AGE_PENALTY_AGE.
    #
    SPOUSE_SCORE_FEMALE_AGE_PENALTY_MULTIPLIER = 50

    ### Brief: SPOUSE_SCORE_LINEALITY_MISMATCH_SCORE ( int32 )
    # This value is added to the spouse score if the marriage is not 
    # of the desired lineality (matrilineal vs. patrilineal).
    #
    SPOUSE_SCORE_LINEALITY_MISMATCH_SCORE = -700

    ### Brief: THREAT_MIN_POWER_RATIO ( Fixed Point )
    # Only consider threats above this ratio.
    #
    THREAT_MIN_POWER_RATIO = 0.5

    ### Brief: THREAT_CLAIM_TIER_MULTIPLIER ( int32 )
    # Multiplied by each claim's tier squared.
    #
    THREAT_CLAIM_TIER_MULTIPLIER = 10

    ### Brief: THREAT_DE_JURE_CLAIM_MULTIPLIER ( int32 )
    # Multiplied for de jure claims.
    #
    THREAT_DE_JURE_CLAIM_MULTIPLIER = 50

    ### Brief: THREAT_MAX_DIPLO_DISTANCE ( int32 )
    # Maximum distance to be considered a threat.
    #
    THREAT_MAX_DIPLO_DISTANCE = 1000

	### Brief: THREAT_POWER_NEIGHBOUR_RATIO_MULTIPLIER ( int32 )
	# Multiplied with the power ratio
	#
	THREAT_POWER_NEIGHBOUR_RATIO_MULTIPLIER = 100

	### Brief: THREAT_POWER_RATIO_MULTIPLIER ( int32 )
	# Multiplied with the power ratio
	#
	THREAT_POWER_RATIO_MULTIPLIER = 50

	### Brief: ENEMY_MAX_POWER_MULTIPLIER ( Fixed Point )
	# Only consider enemies equal or below this ratio
	#
	ENEMY_MAX_POWER_MULTIPLIER = 1.5

	### Brief: ENEMY_CLAIM_TIER_MULTIPLIER ( int32 )
	# Multiplied with each claim's tier squared
	#
	ENEMY_CLAIM_TIER_MULTIPLIER = 10

	### Brief: ENEMY_DE_JURE_CLAIM_MULTIPLIER ( int32 )
	# Multiplied de jure claim
	#
	ENEMY_DE_JURE_CLAIM_MULTIPLIER = 50					
	

	### Brief: FRIEND_ALLY_MAX_DIPLO_DISTANCE ( int32 )
	# Max distance to be considered for a strength ratio bonus
	#
	FRIEND_ALLY_MAX_DIPLO_DISTANCE = 1000

	### Brief: FRIEND_ALLY_MIN_POWER_RATIO ( Fixed Point )
	# Only add power ratio bonus for equal or above this ratio
	#
	FRIEND_ALLY_MIN_POWER_RATIO = 0.25

	### Brief: FRIEND_ALLY_POWER_RATIO_MULTIPLIER ( int32 )
	# Multiplied with the power ratio
	#
	FRIEND_ALLY_POWER_RATIO_MULTIPLIER = 100			
	
	### Brief: MAX_NUMBER_OF_DIPLO_VALUES ( array of int32 )
	# Number of allowed entries in each category (per tier)
	#
	MAX_NUMBER_OF_DIPLO_VALUES = {						
		0
		2
		4
		6
		8
		10
	}
	
	### Brief: MURDER_BASE_CHANCE ( int32 )
	# Chance of the AI starting a murder scheme against a valid target
	#
	MURDER_BASE_CHANCE = 10

	### Brief: PLAYER_INTERACTION_REJECTION_DELAY_MONTHS ( int32 )
	# The AI isn't allowed to resend a rejected interaction until this 
	# many months have passed
	#
	PLAYER_INTERACTION_REJECTION_DELAY_MONTHS = 12		
	
	### Brief: MIN_PATH_COST_TO_CONSIDER_WATER_PATH ( int32 )
	# Number of travel days before AI considers searching for a path 
	# across water instead
	#
	MIN_PATH_COST_TO_CONSIDER_WATER_PATH = 120

	### Brief: MIN_PATH_COST_SAVINGS_TO_CONSIDER_WATER_PATH ( int32 )
	# Number of travel days saved before AI considers going through 
	# water instead
	#
	MIN_PATH_COST_SAVINGS_TO_CONSIDER_WATER_PATH = 65
	
	### Brief: MIN_PATH_COST_TO_CONSIDER_WATER_PATH_FOR_GHW ( int32 )
	# Number of travel days before AI considers searching for a path 
	# across water instead
	#
	MIN_PATH_COST_TO_CONSIDER_WATER_PATH_FOR_GHW = 180

	### Brief: MIN_PATH_COST_SAVINGS_TO_CONSIDER_WATER_PATH_FOR_GHW ( int32 )
	# Number of travel days saved before AI considers going through 
	# water instead
	#
	MIN_PATH_COST_SAVINGS_TO_CONSIDER_WATER_PATH_FOR_GHW = 90
	
	### Brief: MAX_PATH_COST_FACTOR ( int32 )
	# The maximum cost for a path is this factor times the straight
	# path cost
	#
	MAX_PATH_COST_FACTOR = 5							
	
	### Brief: MAX_PATH_COST_FACTOR_TO_CONSIDER_WATER_PATH ( Fixed Point )
	# The maximum cost for a water path is this factor times the cost 
	# of the fastest land path (ignoring enemies, attrition, etc.), 
	# used when AI in on same land body as target
	#
	MAX_PATH_COST_FACTOR_TO_CONSIDER_WATER_PATH = 2.0	
	
	### Brief: RAISE_LEVIES_COOLDOWN ( int32 )
	# Number of days before the AI tries to raise levies if it already 
	# has an army
	#
	RAISE_LEVIES_COOLDOWN = 180

	### Brief: CHECK_ADMIN_ARMIES_COOLDOWN ( int32 )
	# Number of days before the AI tries to get additional armies from
	# administrative themes
	#
	CHECK_ADMIN_ARMIES_COOLDOWN = 360

	### Brief: RAISE_TROOPS_MIN_RATIO_OF_SELF ( Fixed Point )
	# If the AI doesn't have troops raised, it won't raise them unless 
	# the troops amount to at least this much compared to its max 
	# troops
	#
	RAISE_TROOPS_MIN_RATIO_OF_SELF = 0.3

	### Brief: RAISE_TROOPS_MIN_RATIO_OF_ENEMY ( Fixed Point )
	# Or this much compared to its enemy
	#
	RAISE_TROOPS_MIN_RATIO_OF_ENEMY = 0.5

	### Brief: RAISE_ADDITIONAL_TROOPS_RATIO ( Fixed Point )
	# If AI has already rasied some troops and decided they need more 
	# then let AI accumulate this much compare to its possible troops
	# before doing that. It helps to avoid spamming a lot of armies
	# with very little amount of troops
	#
	RAISE_ADDITIONAL_TROOPS_RATIO = 0.2

    ### Brief: REDUCED_EFFECTIVE_WEALTH_PER_HIRED_MERC ( int32 )
    # For each hired merc, the AI pretends to have less money so that 
    # it ends up keeping some reserves.
    #
    REDUCED_EFFECTIVE_WEALTH_PER_HIRED_MERC = 100

    ### Brief: MAX_WEALTH_EXPENDITURE_MERCS ( Fixed Point )
    # The AI will never spend more than this fraction of its current 
    # wealth on buying mercs.
    #
    MAX_WEALTH_EXPENDITURE_MERCS = 0.8

    ### Brief: MERC_OVERMATCHING_TARGET ( Fixed Point )
    # The AI will try to outnumber the enemy by this ratio if it can 
    # afford it based on its warchest.
    #
    MERC_OVERMATCHING_TARGET = 1.25

    ### Brief: MAX_WAR_CHEST_EXPENDITURE_MERC_OVERMATCHING ( Fixed Point )
    # The AI will use up to this much of its warchest when trying to 
    # outnumber the enemy.
    #
    MAX_WAR_CHEST_EXPENDITURE_MERC_OVERMATCHING = 0.7

    ### Brief: MIN_HIRING_GOAL ( int32 )
    # If missing less than this amount to outnumber its enemies, the AI 
    # will hire as if it were actually missing this amount.
    #
    MIN_HIRING_GOAL = 500

    ### Brief: MAX_HIRING_GOAL_OVERFLOW_RATIO ( Fixed Point )
    # The AI won't hire more than this times as many men as it is 
    # missing (using MERC_OVERMATCHING_TARGET). It'll hire the most 
    # expensive merc that fits within this. E.G., this means that if 
    # the AI is missing 1000 men, it'll hire the most expensive merc 
    # with less than 2000 men.
    #
    MAX_HIRING_GOAL_OVERFLOW_RATIO = 1.5

    ### Brief: MONTHS_BEFORE_CONTRACT_END_TO_REHIRE ( int32 )
    # This many months before a merc contract ends, the AI will rehire 
    # mercs if it can afford it and thinks it still needs them.
    #
    MONTHS_BEFORE_CONTRACT_END_TO_REHIRE = 3

    ### Brief: TITLE_GRANT_HATE_THRESHOLD ( int32 )
    # The AI will mostly avoid giving titles to people whose opinion of 
    # them is below this.
    #
    TITLE_GRANT_HATE_THRESHOLD = -25

    ### Brief: TITLE_GRANT_VASSAL_CHILD_SUCCESSION_DISTANCE ( int32 )
    # The AI will give titles to the children of a vassal sometimes if 
    # they're the xth child (ignoring those of a non-preferred gender), 
    # and not in line to inherit anything.
    #
    TITLE_GRANT_VASSAL_CHILD_SUCCESSION_DISTANCE = 3

    ### Brief: SCHEME_COUNTERMESURE_SWITCH_SCORE ( Fixed Point )
    # New countermeasure needs to be this much more valuable than the 
    # current one.
    # 
    # In order for the AI to switch to a different option, the new one
    # needs to have a score that's at least the score of the current
    # task multiplied with this.
    #
    # That is, if the value below is set to 1.25, then it means the new
    # option needs to be of a 25% higher value.
    #
    SCHEME_COUNTERMESURE_SWITCH_SCORE = 1.25

    ### Brief: COUNCIL_TASK_SWITCH_SCORE ( Fixed Point )
    # New councilor task needs to be this much more valuable than the 
    # current one.
    # 
    # In order for the AI to switch to a different option, the new one
    # needs to have a score that's at least the score of the current
    # task multiplied with this.
    #
    # That is, if the value below is set to 1.25, then it means the new
    # option needs to be of a 25% higher value.
    #
    COUNCIL_TASK_SWITCH_SCORE = 1.25

    ### Brief: TOUGHNESS_SCORE_MULT ( int32 )
    # Multiplier used to evaluate the toughness score for buying or 
    # disbanding Men-at-Arms.
    #
    TOUGHNESS_SCORE_MULT = 10

    ### Brief: ATTACK_SCORE_MULT ( int32 )
    # Multiplier used to evaluate the attack score for buying or 
    # disbanding Men-at-Arms.
    #
    ATTACK_SCORE_MULT = 10

    ### Brief: PURSUIT_SCORE_MULT ( int32 )
    # Multiplier used to evaluate the pursuit score for buying or 
    # disbanding Men-at-Arms.
    #
    PURSUIT_SCORE_MULT = 3

    ### Brief: SCREEN_SCORE_MULT ( int32 )
    # Multiplier used to evaluate the screen score for buying or 
    # disbanding Men-at-Arms.
    #
    SCREEN_SCORE_MULT = 1

    ### Brief: SIEGE_VALUE_SCORE_MULT ( int32 )
    # Multiplier used to evaluate the siege value for buying or 
    # disbanding Men-at-Arms.
    #
    SIEGE_VALUE_SCORE_MULT = 1000

    ### Brief: NEGATIVE_SCORE_PER_EXISTING_REGIMENT ( int32 )
    # How much is the score of the regiment type reduced per existing 
    # subregiment of that type?
    #
    NEGATIVE_SCORE_PER_EXISTING_REGIMENT = 20

    ### Brief: RANDOM_REGIMENT_SCORE_MAX ( Fixed Point )
    # How much extra score can the AI randomly give to this regiment? 
    # Will always be the same for the same character + regiment. 0.2 
    # means 0-20% extra.
    #
    RANDOM_REGIMENT_SCORE_MAX = 0.2

    ### Brief: NORMAL_SUB_REGIMENTS_PER_SIEGE_SUB_REGIMENT ( int32 )
    # How many non-siege regiments should there be for each siege 
    # regiment? Siege will always be the first sub-regiment purchased, 
    # and the AI will maintain this ratio.
    #
    NORMAL_SUB_REGIMENTS_PER_SIEGE_SUB_REGIMENT = 5

    ### Brief: SUBTRACT_NORMAL_SUB_REGIMENTS_FOR_SIEGE_PURPOSES ( int32 )
    # Ignore this many normal regiments when buying siege 
    # sub-regiments. This effectively means the AI will buy their first 
    # siege weapon after this many normal ones, and then one more for 
    # every NORMAL_SUB_REGIMENTS_PER_SIEGE_SUB_REGIMENT additional 
    # normal sub-regiments.
    #
    SUBTRACT_NORMAL_SUB_REGIMENTS_FOR_SIEGE_PURPOSES = 3

    ### Brief: REGIMENT_OBSOLETION_SCORE_DIFFERENCE ( int32 )
    # The AI will disband a regiment if it is this much worse than the 
    # best available regiment, and it is unable to hire more regiments 
    # (due to cost or being at cap). Quick math: 10 damage * 100 men / 
    # 200 cost = 5 score difference.
    #
    REGIMENT_OBSOLETION_SCORE_DIFFERENCE = 20


	### Brief: AI_BASE_WAR_CHANCE
	# Basic chance of declaring war. Further reduced by energy; x0 at
	# -100, x1 at 100, x0.5 at 0 energy.
	#
	AI_BASE_WAR_CHANCE = 1							

	### Brief: AI_WAR_BASE_COOLDOWN
	# How long, in days, does the AI have to wait between wars?
	#
	AI_WAR_BASE_COOLDOWN = 50							
	
	### Brief: AI_WAR_COOLDOWN_RATIO_FOR_FULL_CHANCE ( int )
	# How far beyond the cooldown do you have to go before the time 
	# since the last war stops reducing the chance? 
	#
	# Once the number of day since the last offensive war exceeds this
	# number times the offensive war cooldown, the AI will no longer 
	# have a chance to not try to select a CB to use. 
	#
	# If this number is 1 or less, the AI will always look at a CB to 
	# use once the cooldown has expired.
	#
	AI_WAR_COOLDOWN_RATIO_FOR_FULL_CHANCE = 0	

	### Brief: AI_WAR_MAX_OFFENSIVE_WAR_PENALTY ( Fixed Point )
	# If your offensive war penalty is higher than this, don't declare 
	# war unless you're a warmonger (faith doctrine) or irrational
	#
	AI_WAR_MAX_OFFENSIVE_WAR_PENALTY = 0.0				
	
	### Brief: AI_WAR_MIN_RATIONALITY_FOR_OFFENSIVE_WAR_PENALTY ( Fixed Point )
	# At or below this value, the AI will declare war even if their 
	# offensive war penalty is high
	# 
	AI_WAR_MIN_RATIONALITY_FOR_OFFENSIVE_WAR_PENALTY = -30	
	
	### Brief: MIN_SCORE_RATIO_FOR_CASUS_BELLI ( Fixed Point )
	# The AI will never declare a war below this ratio of the best war 
	# it has available
	#
	MIN_SCORE_RATIO_FOR_CASUS_BELLI = 0.9				

	### Brief: AI_VENGEFULLNESS_FOR_WAR_WITH_HOSTAGE ( int )
	# AI must be at least this vengeful to attack a target warden of 
	# their hostage
	#
	AI_VENGEFULLNESS_FOR_WAR_WITH_HOSTAGE = 50			
	
	### Brief: AI_COMPASSION_FOR_WAR_WITH_HOSTAGE ( int )
	# AI must be less compassionate than this to attack a target warden
	# of their hostage
	#
	AI_COMPASSION_FOR_WAR_WITH_HOSTAGE = -50			
	
	### Brief: AI_HONOR_FOR_WAR_WITH_HOSTAGE ( int )
	# AI must be less honorable than this to attack a target if they 
	# are bound by hostages
	#
	AI_HONOR_FOR_WAR_WITH_HOSTAGE = -50					
	
	### Brief: AI_RATIONALITY_FOR_WAR_WITH_HOSTAGE ( int )
	# AI warden must be less rational than this to attack a target who 
	# gave them hostage
	#
	AI_RATIONALITY_FOR_WAR_WITH_HOSTAGE = -50			
	
	### Brief: AI_BOLDNESS_FOR_WAR_WITH_HOSTAGE ( int )
	# AI warden must be at least this bold to attack a target who gave
	# them hostage
	#
	AI_BOLDNESS_FOR_WAR_WITH_HOSTAGE = 50				
	
	### Brief: AI_BOLDNESS_ADJUSTMENT_FACTOR_ADMIN_REALM_POWER ( Fixed Point )
	# Multiplication on the base assumption a ruler makes based on 
	# their boldness as to how efficient an admin realm's governors
	# are. At 1.0 this translates to the extreme case where a ruler 
	# with 100 boldness will estimate an admin realm's power at 50% 
	# efficiency in either direction, depending on whether or not they
	# are attacker or defender. 
	#
	# Example: A ruler with 100 boldness looks to attack an admin 
	# 	realm. They will think all governors are only 50% efficient. 
	#	On the flipside a admin ruler with 100 boldness will think 
	# 	their governors operate at 150% efficiency.
	#
	# No matter the adjustment, the result will always be between 50% 
	# and 150% governor efficiency. 
	#
	AI_BOLDNESS_ADJUSTMENT_FACTOR_ADMIN_REALM_POWER = 1.0

	### Brief: AI_CHANCE_TO_START_WAR_WITH_HOSTAGE ( Fixed Point )
	# How likely is AI to attack a target if they are bound by hostages.
	# Random chance between [0, 1)
	#
	AI_CHANCE_TO_START_WAR_WITH_HOSTAGE = 0.5

	### Brief: CB_SCORE_DE_JURE_MULTIPLIER ( Fixed Point )
	# If the title is de jure under the AI character
	#
	CB_SCORE_DE_JURE_MULTIPLIER = 100					
	
	### Brief: CB_SCORE_DE_JURE_UNDER_LIEGE_MULTIPLIER ( Fixed Point )
	# If the title is de jure under the AI character's liege
	#
	CB_SCORE_DE_JURE_UNDER_LIEGE_MULTIPLIER = 1.5		
	
	### Brief: CB_SCORE_DE_JURE_UNDER_HIGHER_TITLE_MULTIPLIER ( Fixed Point )
	# If the title is de jure under the de jure title directly above an
	# independent AI character
	#
	CB_SCORE_DE_JURE_UNDER_HIGHER_TITLE_MULTIPLIER = 25	
	
	### Brief: CB_SCORE_HIGHER_TITLE_MULTIPLIER ( Fixed Point )
	# If the title is a higher tier than the AI character's current 
	# primary title
	#
	CB_SCORE_HIGHER_TITLE_MULTIPLIER = 100				

	### Brief: EXTRA_CB_SCORE_FOR_HOLY_SITES ( Fixed Point )
	# The AI will assign this much extra score to conquering a province
	# that is its holy site
	#
	EXTRA_CB_SCORE_FOR_HOLY_SITES = 10					
	
	### Brief: CB_SCORE_MULT_NEIGHBOR_TITLE ( Fixed Point )
	# The AI will multiply the score of neighboring titles taken by a 
	# CB by this much
	#
	CB_SCORE_MULT_NEIGHBOR_TITLE = 15					
	
	### Brief: TARGET_MAX_DEFENSIVE_WARS ( Fixed Point )
	# AI won't declare war on someone who already has this many or more
	# defensive wars
	#
	TARGET_MAX_DEFENSIVE_WARS = 3						

	### Brief: DESIRED_WAR_SIDE_POWER ( Fixed Point )
	# AI won't call in more allies if its side in a war has at least 
	# this ratio of troops compared to the enemy. Uses current power
	# for own side, max power for enemy side.
	#
	DESIRED_WAR_SIDE_POWER = 1.25					
	
	### Brief: CB_TARGET_MAX_POWER ( Fixed Point )
	# AI won't look for CB:s against anyone stronger than this. Used by
	# independent rulers.
	#
	CB_TARGET_MAX_POWER = 3.0

	### Brief: CB_TARGET_MAX_POWER_VASSAL ( Fixed Point )
	# AI won't look for CB:s against anyone stronger than this. Used by
	# vassal rulers.
	#
	CB_TARGET_MAX_POWER_VASSAL = 2.0					
	
	### Brief: CB_TARGET_AT_PEACE_POWER_RATIO_MAX ( Fixed Point )
	# AI won't declare a war on someone stronger than this if they are 
	# at peace
	#
	CB_TARGET_AT_PEACE_POWER_RATIO_MAX = 1.0

	### Brief: CB_TARGET_AT_WAR_POWER_RATIO_MAX ( Fixed Point )
	# AI won't declare a war on someone stronger than this if they are 
	# already at war
	#
	CB_TARGET_AT_WAR_POWER_RATIO_MAX = 1.5

	### Brief: CB_TARGET_AT_WAR_POWER_RATIO_PER_WAR ( Fixed Point )
	# Added per war the target character is in above the first one, but
	# only counts wars where the target is the primary attacker or 
	# defender
	#
	CB_TARGET_AT_WAR_POWER_RATIO_PER_WAR = 0.25

	### Brief: CB_TARGET_POWER_RATIO_BOLDNESS ( Fixed Point )
	# Multiplied by positive boldness, so 0.0 at zero and 0.25 at 100
	#
	CB_TARGET_POWER_RATIO_BOLDNESS = 0.25

	### Brief: ADMIN_REALM_TOTAL_POWER_ADJUSTMENT_TOP_LIEGE ( Fixed Point )
	# How much of an admin realm's total power does the AI estimate it
	# can realistically bring to bear. Used by both actors looking to 
	# attack an AI realm and AI admin realm top lieges looking to 
	# attack. 
	#
	ADMIN_REALM_TOTAL_POWER_ADJUSTMENT_TOP_LIEGE = 0.4

	### Brief: ADMIN_REALM_TOTAL_POWER_ADJUSTMENT_VASSAL ( Fixed Point )
	# How much of an admin realm's total power does the AI estimate it
	# can realistically bring to bear. Used by admin vassals within an
	# admin realm when looking to attack outwards. 
	#
	ADMIN_REALM_TOTAL_POWER_ADJUSTMENT_VASSAL = 0.05

	### Brief: ADMIN_REALM_VASSAL_OFFENSIVE_WAR_INFLUENCE_SPENDING_FLOOR ( int32 )
	# How much influence will an admin vassal hold back to spending on 
	# administrative armies when in an offensive war. 
	#
	ADMIN_REALM_VASSAL_OFFENSIVE_WAR_INFLUENCE_SPENDING_FLOOR = 400

	### Brief: ADMIN_REALM_TOP_LIEGE_OFFENSIVE_WAR_INFLUENCE_SPENDING_FLOOR ( int32 )
	# How much influence will an admin top liege hold back to spending
	# on administrative armies when in an offensive war. 
	#
	ADMIN_REALM_TOP_LIEGE_OFFENSIVE_WAR_INFLUENCE_SPENDING_FLOOR = 400

	### Brief: ADMIN_REALM_TOP_LIEGE_DEFENSIVE_WAR_INFLUENCE_SPENDING_FLOOR ( int32 )
	# How much influence will an admin top liege hold back to spending 
	# on administrative armies when in an defensive war. 
	#
	ADMIN_REALM_TOP_LIEGE_DEFENSIVE_WAR_INFLUENCE_SPENDING_FLOOR = 400
	
	### Brief: ENEMY_COMBAT_POWER_MULTIPLIER ( Fixed Point )
	# The AI will take its estimated enemy strength times this 
	# multiplier
	#
	ENEMY_COMBAT_POWER_MULTIPLIER = 1.1

    ### Brief: CB_OPINION_OF_TARGET_MULTIPLIER ( Fixed Point )
    # Multiplier for opinion of target.
    #
    CB_OPINION_OF_TARGET_MULTIPLIER = 0.1

    ### Brief: CB_OPINION_OF_CLAIMANT_MULTIPLIER ( Fixed Point )
    # Multiplier for opinion of claimant (if claimant is the AI, we 
    # use MAX_OPINION).
    #
    CB_OPINION_OF_CLAIMANT_MULTIPLIER = 0.1

    ### Brief: CB_CLAIMANT_BECOMES_INDEPENDENT_MULTIPLIER ( Fixed Point )
    # Multiplier if the claimant becomes independent due to this CB.
    #
    CB_CLAIMANT_BECOMES_INDEPENDENT_MULTIPLIER = 0.25

    ### Brief: CB_CLAIMANT_IS_CLOSE_RELATIVE_MULTIPLIER ( int32 )
    # Multiplier if the claimant is a close relative.
    #
    CB_CLAIMANT_IS_CLOSE_RELATIVE_MULTIPLIER = 2

    ### Brief: CB_CLAIMANT_IS_NOT_CLOSE_RELATIVE_MULTIPLIER ( Fixed Point )
    # Multiplier if the claimant is not a close relative.
    #
    CB_CLAIMANT_IS_NOT_CLOSE_RELATIVE_MULTIPLIER = 0.75

    ### Brief: CB_CLAIMANT_GREED_MULTIPLIER ( Fixed Point )
    # Multiplier of the AI's greed when scoring a CB for a claimant. 
    # Full greed gives this value, while full generosity gives the 
    # positive equivalent.
    #
    CB_CLAIMANT_GREED_MULTIPLIER = -0.5

    ### Brief: COUNTER_RAID_MIN_DISTANCE ( int32 )
    # The AI will try to raise counter-raid troops at least this far 
    # away from the raid.
    #
    COUNTER_RAID_MIN_DISTANCE = 75

    ### Brief: COUNTER_RAID_MAX_DISTANCE ( int32 )
    # The AI will raise counter-raid troops at most this far away from 
    # the raid.
    #
    COUNTER_RAID_MAX_DISTANCE = 200

    ### Brief: OTHER_RAID_ARMY_COMBINED_STRENGTH_MAX_DISTANCE ( int32 )
    # Other raid armies no more than this far away will be considered 
    # as part of the same raid army for strength purposes.
    #
    OTHER_RAID_ARMY_COMBINED_STRENGTH_MAX_DISTANCE = 200

    ### Brief: VASSAL_COUNTER_RAID_MIN_STRENGTH_RATIO ( Fixed Point )
    # A vassal at least this strong compared to the raid will be 
    # responsible for countering it.
    #
    VASSAL_COUNTER_RAID_MIN_STRENGTH_RATIO = 0.9

    ### Brief: INDEPENDENT_COUNTER_RAID_MIN_STRENGTH_RATIO ( Fixed Point )
    # An independent ruler at least this strong compared to the raid 
    # will be responsible for countering it if no vassal does.
    #
    INDEPENDENT_COUNTER_RAID_MIN_STRENGTH_RATIO = 0.75

    ### Brief: MAX_RAID_DISTANCE ( int32 array )
    # How far away will the AI raid? Uses naval distance.
    #
    # - 0: Default range
    # - 1000: Range from Agder to Brittany/Ireland
    # - 1200: Range from Agder to Western France
    # - 3000: Range from Agder to Southern Spain
    # - 4000: Range from Agder to Rome
    #
	MAX_RAID_DISTANCE = {
		0
		0
		1000
		1200
		3000
		4000
	}							

	### Brief: MAX_RAID_DISTANCE_NEXT_COUNTY (  Fixed Point  )
	# After raiding one county, how far is the AI willing to go to the 
	# next?
	#
	MAX_RAID_DISTANCE_NEXT_COUNTY = 200

	### Brief: MIN_STRENGTH_TO_RAID_VASSAL (  Fixed Point  )
	# How strong do vassals have to be for the AI to go raiding?
	#
	MIN_STRENGTH_TO_RAID_VASSAL = 500

	### Brief: MIN_STRENGTH_TO_RAID_INDEPENDENT (  Fixed Point  )
	# How strong do independent rulers have to be for the AI to go 
	# raiding?
	#
	MIN_STRENGTH_TO_RAID_INDEPENDENT = 300

	### Brief: MAX_RAID_TARGET_STRENGTH (  Fixed Point  )
	# Don't raid enemies too strong.
	#
	MAX_RAID_TARGET_STRENGTH = 1.5

	### Brief: MAX_RAID_TARGET_STRENGTH_AT_WAR (  Fixed Point  )
	# But if they're at war, the risk might be worth it.
	#
	MAX_RAID_TARGET_STRENGTH_AT_WAR = 5.0

	### Brief: MIN_STRENGTH_FOR_RAIDER_TO_AVOID (  Fixed Point  )
	# If there's hostile units in this county and neighboring counties 
	# that are combined this strong compared to the raid army, flee
	# home.
	#
	MIN_STRENGTH_FOR_RAIDER_TO_AVOID = 0.9

	### Brief: RAID_SCORE_MIN_STRENGTH_RATIO (  Fixed Point  )
	# We divide the score by how strong the target is compared to us;
	# if lower than this, we use this number. So 0.2 means that
	# outnumbering them 5:1 and 2:1 are equivalent.
	#
	RAID_SCORE_MIN_STRENGTH_RATIO = 0.2

	### Brief: RAID_SCORE_DISTANCE_OFFSET ( int32 )
	# We divide the score by the distance from the realm (or army, if 
	# follow-up raid) plus this number.
	#
	RAID_SCORE_DISTANCE_OFFSET = 200

	### Brief: RAID_SCORE_DISTANCE_OFFSET_NEXT_TARGET ( int32 )
	# We divide the score by the distance from the army plus this
	# number when finding the next county to go to.
	#
	RAID_SCORE_DISTANCE_OFFSET_NEXT_TARGET = 30

	### Brief: RAID_SCORE_FORT_LEVEL_OFFSET ( int32 )
	# We divide the score by the sum of all fort levels in the county, 
	# plus this number.
	#
	RAID_SCORE_FORT_LEVEL_OFFSET = 5

	### Brief: MIN_RAID_SCORE_COMPARED_TO_BEST_SCORE (  Fixed Point  )
	# Scores this much worse than the best score are just discarded.
	#
	MIN_RAID_SCORE_COMPARED_TO_BEST_SCORE = 0.4

	### Brief: RAID_CHANCE_AT_MAX_GREED ( Fixed Point )
	# Chance to go raiding each year if at 100 greed. 0.0 at -100 greed. 
	# Must still meet all other conditions.
	#
	RAID_CHANCE_AT_MAX_GREED = 0.9

	### Brief: MAX_RAID_DAYS ( int32 )
	# After this long, the AI will go home when a raid action concludes.
	#
	MAX_RAID_DAYS = 365

	### Brief: RAID_COOLDOWN_DAYS ( int32 )
	# The AI won't start a new raid for this long after last having 
	# started one.
	#
	RAID_COOLDOWN_DAYS = 1825

	### Brief: COUNTER_RAID_COOLDOWN_DAYS ( int32 )
	# The AI won't counter-raid for this long after they last 
	# counter-raided.
	#
	COUNTER_RAID_COOLDOWN_DAYS = 180

	### Brief: RAID_SCORE_FAITH_HOSTILITY_MULT ( Fixed Point array )
	# Hostility levels start at 0 (same faith or equivalent to same
	# faith)
	#
	# Raid score mult based on hostility
	#
	RAID_SCORE_FAITH_HOSTILITY_MULT = {
		1
		1.5
		2
		3
	}
	RAID_SCORE_MULT_SAME_CULTURE = 0.5
	RAID_SCORE_MULT_SAME_HERITAGE = 0.75
	
	### Brief: CHASE_MIN_SIZE ( int32 )
	# The AI will not bother trying to chase armies smaller than this.
	#
	CHASE_MIN_SIZE = 500

    ### Brief: CHASE_PRIMARY_ENEMY_MIN_SCORE ( Fixed Point )
    # Score is between 0.0 and 1.0 and represents the percentage of 
    # the enemy's total strength the target unit contains. If led by 
    # the primary enemy, the score is capped to this minimum.
    #
    CHASE_PRIMARY_ENEMY_MIN_SCORE = 0.75

    ### Brief: CHASE_PRIMARY_ENEMY_SOLDIER_MODIFIER ( Fixed Point )
    # Modifies the number of target unit soldiers when considering if 
    # it's worth taking hostile attrition to attack it. I.e. AI won't 
    # attack a unit with 200 if it loses more by moving there.
    #
    CHASE_PRIMARY_ENEMY_SOLDIER_MODIFIER = 2.0

    ### Brief: CHASE_MAX_SPEED_DIFFERENCE ( Fixed Point )
    # Ignore chasing units that are this much faster unless adjacent.
    #
    CHASE_MAX_SPEED_DIFFERENCE = 0.2


	### Brief: UPDATE_WAR_STANCE_TICK ( int32 )
	# How often should the AI reevaluate its warstance? 
	#
	UPDATE_WAR_STANCE_TICK = 30

	### Brief: UPDATE_SPLIT_MERGE_TICK ( int32 )
	# How often should the AI evaluate splitting and merging unit 
	# stacks? 
	#
	UPDATE_SPLIT_MERGE_TICK = 14

	### Brief: UPDATE_TARGETS_TICK ( int32 )
	# How often should the AI update targets under normal
	# circumstances? Also sets how often a unit stack should be idle
	# before it retries getting orders. 
	#
	UPDATE_TARGETS_TICK = 7

	### Brief: UPDATE_TARGETS_TICK_LOPSIDED ( int32 )
	# How often should the AI update targets when the war is lopsided?
	# Lopsided when the one side is weaker than the other by a factor 
	# of LOPSIDED_WAR_RATIO_THRESHOLD. Also sets how often a unit stack
	# should be idle before it retries getting orders.
	#
	UPDATE_TARGETS_TICK_LOPSIDED = 14
	
	### Brief: COMBAT_RATIO_THRESHOLD ( Fixed Point )
	# The AI will consider it valid to enter provinces where the 
	# predicted combat ratio compared to nearby enemies is above this
	# value.
	#
	COMBAT_RATIO_THRESHOLD = 0.5

	### Brief: COMBAT_RATIO_THRESHOLD ( Fixed Point )
	# When in desperate mode, the AI will consider it valid to enter 
	# provinces where the predicted combat ratio compared to nearby
	# enemies is above this value
	#
	COMBAT_RATIO_THRESHOLD_DESPERATE = 0.4

	### Brief: ASK_FOR_HELP_COMBAT_PREDICTION_RATIO ( Fixed Point )
	# Below this combat prediction ratio the AI will try to call in 
	# more troops
	#
	ASK_FOR_HELP_COMBAT_PREDICTION_RATIO = 0.66

	### Brief: STOP_ASKING_FOR_HELP_COMBAT_PREDICTION_RATIO ( Fixed Point )
	# If a unit stack is currently calling for help, at what combat 
	# prediction ratio will they stop calling for more reinforcements? 
	#
	STOP_ASKING_FOR_HELP_COMBAT_PREDICTION_RATIO = 0.75

	### Brief: ASK_FOR_HELP_OTHER_STACK_TROOPS_RATIO ( Fixed Point )
	# How badly does a unit stack need to be out-powered before other,
	# nearby unit stacks intervenes to help them?
	# 
	# A unit stack is one collective army that acts as a unit. This 
	# stack may be split into multiple subunit stacks. Typically there
	# are only multiple unit stacks if the AI's side outnumbers the 
	# other side by a sufficient margin.  
	#
	ASK_FOR_HELP_OTHER_STACK_TROOPS_RATIO = 1.5

	### Brief: ASK_FOR_HELP_OTHER_STACK_TROOPS_BREAK_SIEGE_RATIO ( Fixed Point )
	# How badly does a unit stack need to be out-powered before other,
	# nearby unit stacks intervenes to help them, even if it breaks a 
	# siege? Takes the place of ASK_FOR_HELP_OTHER_STACK_TROOPS_RATIO
	# if BREAK_SIEGE_TO_HELP_PROGRESS_THRESHOLD is met.
	#
	ASK_FOR_HELP_OTHER_STACK_TROOPS_BREAK_SIEGE_RATIO = 1.7

	### Brief: BREAK_SIEGE_DAYS_LEFT_THRESHOLD ( int32 )
	# How far along a siege must a siege be before it uses the more
	# conservative ASK_FOR_HELP_OTHER_STACK_TROOPS_BREAK_SIEGE_RATIO
	# instead of ASK_FOR_HELP_OTHER_STACK_TROOPS_RATIO?
	#
	BREAK_SIEGE_TO_HELP_PROGRESS_THRESHOLD = 0.6

	### Brief: RETREAT_COMBAT_PREDICTION_RATIO ( Fixed Point )
	# Below this combat prediction ratio the AI will retreat.
	#
	# The AI will only retreat if the following are true:
	# -	AND :
	# 	-	It predicts it'll lose according to 
	#		RETREAT_COMBAT_PREDICTION_RATIO
	#	-	OR:
	# 		- 	it either has significant forces elsewhere,
	# 		- 	there's a better defensive location nearby as defined 
	#			by RETREAT_TO_BETTER_TERRAIN_DISTANCE
	#
	RETREAT_COMBAT_PREDICTION_RATIO = 0.45

	### Brief: RETREAT_TO_BETTER_TERRAIN_DISTANCE ( Fixed Point )
	# The AI will retreat to better terrain this many provinces away.
	# The AI might do another retreat once it gets there.
	#
	# The AI will only retreat if the following are true:
	# -	AND :
	# 	-	It predicts it'll lose according to 
	#		RETREAT_COMBAT_PREDICTION_RATIO
	#	-	OR:
	# 		- 	it either has significant forces elsewhere,
	# 		- 	there's a better defensive location nearby as defined 
	#			by RETREAT_TO_BETTER_TERRAIN_DISTANCE
	#	
	RETREAT_TO_BETTER_TERRAIN_DISTANCE = 2				

	### Brief: RETREAT_IF_MISSING_STRENGTH ( Fixed Point )
	# The AI will retreat if it has this many troops elsewhere compared
	# to the potentially retreating army. E.G., if 2000 men are 
	# considered for retreat, it'll do so if there's at least 
	# 0.25 * 2000 = 500 men elsewhere
	#
	RETREAT_IF_MISSING_STRENGTH = 0.25

	### Brief: STAND_AND_FIGHT_DAYS ( int32 )
	# If the AI decides to stand still so the other party can kill it on
	# defensible terrain, it'll start doing regular orders again after
	# this many days if death is not forthcoming
	#
	STAND_AND_FIGHT_DAYS = 30

	### Brief: STAND_AND_FIGHT_COOLDOWN_DAYS ( int32 )
	# If the AI abandons "stand and fight" due to the above, it'll
	# avoid "stand and fight" for this many days
	#
	STAND_AND_FIGHT_COOLDOWN_DAYS = 45


	### Brief: MIN_GOALS_PER_STACK ( int32 )
	# Of all potential target goals found, each unit stack will only do
	# a final evaluation, including pathfinding, on the top x ones.
	#
	MIN_GOALS_PER_STACK = 10

	### Brief: MIN_SUPPLY_COMPARED_TO_AVERAGE_SUPPLY_FACTOR ( int32 )
	# For the purpose of army sizes, the AI uses the highest of this
	# factor times the average supply in the war area, and the lowest
	# supply in the war area. E.G., if average supply is 2k, and lowest
	# supply is 1k, the AI will act as if available supply is 
	# 0.7 * 2k = 1.4k. But if the lowest supply was 1.5k, it'd be using
	# that instead
	#
	MIN_SUPPLY_COMPARED_TO_AVERAGE_SUPPLY_FACTOR = 0.7	

	### Brief: WANTED_POWER_RATIO_AGAINST_ENEMY_FOR_WAR_PLAN ( Fixed Point )
	# How much power do we want to allocate to a war plan when compared
	# to the enemy's maximum power? 
	#
	WANTED_POWER_RATIO_AGAINST_ENEMY_FOR_WAR_PLAN = 1.25

	### Brief: STRONGEST_OPPONENT_SIZE_MULTIPLIER ( Fixed Point )
	# When calculating how much a strength is needed per stack, try to
	# outnumber the strongest opponent by this much.
	#
	STRONGEST_OPPONENT_SIZE_MULTIPLIER = 1.5

	### Brief: MIN_STACK_SIZE_THRESHOLD ( Fixed Point )
	# When splitting and merging unit stacks, the stack will try to 
	# merge with another stack if its strength is below this threhold.
	#
	# MinStackSize = PreferredStackSize * MIN_STACK_SIZE_THRESHOLD
	#
	MIN_STACK_SIZE_THRESHOLD = 0.75

	### Brief: MAX_STACK_SIZE_SPLIT_THRESHOLD ( Fixed Point )
	# When splitting and merging unit stacks, the stack will split when
	# a stack's current strength is above this threshold. 
	#
	# SplitThreshold = PreferredStackSize * STACK_SIZE_SPLIT_THRESHOLD
	#
	STACK_SIZE_SPLIT_THRESHOLD = 1.1

	### Brief: SUPPLY_LIMIT_SPLIT_SIZE_PADDING ( Fixed Point )
	# When splitting armies into smaller stacks, we multiply the war
	# coordinator's supply limit with this number to get a bit of 
	# leeway when making substacks. If a stack is above the resulting
	# number, we want to split it into smaller substacks. 
	#
	SUPPLY_LIMIT_SPLIT_SIZE_PADDING = 1.1

	### Brief: GREAT_HOLY_WAR_SUPPLY_LIMIT_TOLERANECE ( Fixed Point )
	# Additional multiplier to SUPPLY_LIMIT_SPLIT_SIZE_PADDING for the 
	# tolerance of province supply limit during Great Holy Wars. 
	#
	GREAT_HOLY_WAR_SUPPLY_LIMIT_TOLERANECE = 2.0

	### Brief: IDEAL_ENEMY_POWER_TO_TARGET ( Fixed Point )
	# When scoring enemy armies to target, we use one scoring method
	# when the enemy army is weaker than ours by this threshold. In 
	# short: focus on enemies around half our power.
	#
	# 		IdealEnemyPower = OurPower * IDEAL_ENEMY_POWER_TO_TARGET
	# 
	# When enemies are: 
	#		EnemyPower <= IdealEnemyPower
	#	We multiply the the unit priority by: 
	#		Multiplier = 0.5 + 0.5 * ( EnemyPower / IdealEnemyPower ) 
	#	Leading to a multiplier between 0.5 and 1.0. 
	#
	# When enemies are: 
	#		EnemyPower > IdealEnemyPower
	#	We multiply the the unit priority by: 
	#		Multiplier = ( OurPower - EnemyPower ) / IdealEnemyPower 
	#	Such that the multiplier goes down from 1.0 to 0.0. 
	#
	# In both cases the Multiplier are then adjusted such that: 
	#	0.0 <= Multiplier <= 1.0
	#
	IDEAL_ENEMY_POWER_TO_TARGET = 0.5

	### Brief: HOSTILE_UNIT_PRIORITY_MULTIPLIER ( Fixed Point )
	# The multiplier to the hostile unit score. How much more, or less,
	# should the war coordinator care about hostile units?
	#
	HOSTILE_UNIT_PRIORITY_MULTIPLIER = 0.5

	### Brief: RAIDER_UNIT_PRIORITY_MULTIPLIER ( Fixed Point )
	# The multiplier to the raider unit score. How much more, or less,
	# should the war coordinator care about raider units?
	#
	RAIDER_UNIT_PRIORITY_MULTIPLIER = 0.9

	### Brief: ARMY_SIZE_COMPARED_TO_SUPPLY ( int32 )
	# How much larger than the supply are we willing to make a stack?
	# "Supply" here refers to the same number as
	# MIN_SUPPLY_COMPARED_TO_AVERAGE_SUPPLY_FACTOR does
	#
	ARMY_SIZE_COMPARED_TO_SUPPLY = 10

	### Brief: RESUPPLY_MAX_DISTANCE ( int32 )
	# How far out can splinters of the army spread when trying to
	# resupply? In # of provinces. AI will try to keep it lower if
	# possible.
	#
	RESUPPLY_MAX_DISTANCE = 3

	### Brief: RESUPPLY_COOLDOWN_DAYS ( int32 )
	# If supplying is interrupted due to insufficient supply, wait for
	# this long before trying to resupply again.
	#
	RESUPPLY_COOLDOWN_DAYS = 250						

	### Brief: AVOID_BAD_ADJACENCY_COMBAT_PREDICTION_RATIO ( Fixed Point )
	# Below this combat prediction ratio the AI will try to find a
	# better way.
	#
	AVOID_BAD_ADJACENCY_COMBAT_PREDICTION_RATIO = 0.625

	### Brief: AVOID_BAD_ADJACENCY_MAX_PATHFIND_EXTRA_COST ( Fixed Point )
	# Max additional cost for a path that avoids going over a bad
	# adjacency just before the target destination.
	#
	AVOID_BAD_ADJACENCY_MAX_PATHFIND_EXTRA_COST = 180.0	

	### Brief: CLOSE_TO_VICTORY_WAR_SCORE ( int )
	# When the AI has this much war score or more, it considers itself 
	# close to victory, and will prioritize ongoing objectives that can
	# finish the war.
	#
	CLOSE_TO_VICTORY_WAR_SCORE = 80

	### Brief: CLOSE_TO_VICTORY_REMAINING_OCCUPATION_WAR_SCORE ( int )
	# When the AI fulfills CLOSE_TO_VICTORY_WAR_SCORE and it it can 
	# gain this value or more war score from sieges, it will prioritize
	# sieges. This will cause CLOSE_TO_VICTORY_REMAINING_OCCUPATION_MULTIPLIER
	# to apply to the TARGET_WILL_BREAK_ONGOING_SIEGE penalty. 
	#
	CLOSE_TO_VICTORY_REMAINING_OCCUPATION_WAR_SCORE = 20

	### Brief: CLOSE_TO_VICTORY_REMAINING_OCCUPATION_MULTIPLIER ( Fixed Point )
	# When CLOSE_TO_VICTORY_REMAINING_OCCUPATION_WAR_SCORE fulfilled,
	# this multiplier will be applied to the
	# TARGET_WILL_BREAK_ONGOING_SIEGE penalty to break an ongoing siege
	#
	CLOSE_TO_VICTORY_REMAINING_OCCUPATION_MULTIPLIER = 2.0

	### Brief: CLOSE_TO_VICTORY_REMAINING_BATTLE_WAR_SCORE ( int )
	# When the AI fulfills CLOSE_TO_VICTORY_WAR_SCORE and it it can 
	# gain this value or more war score from battles, it will 
	# prioritize battles. This will cause the effect of
	# enemy_unit_priority from the war stance to get multiplied by 
	# CLOSE_TO_VICTORY_REMAINING_BATTLE_MULTIPLIER. 
	#
	# It is important to note that this values is also affected by the
	# calculations of IDEAL_ENEMY_POWER_TO_TARGET, such that weaker
	# enemy armies are even more strongly targeted when this is in
	# effect. Therefore it is important to note that this calculation
	# can cause the AI to break sieges, if they think they can pick an
	# easy battle to win a war.
	#
	CLOSE_TO_VICTORY_REMAINING_BATTLE_WAR_SCORE = 20

	### Brief: CLOSE_TO_VICTORY_REMAINING_BATTLE_MULTIPLIER ( Fixed Point )
	# When CLOSE_TO_VICTORY_REMAINING_BATTLE_WAR_SCORE fulfilled,
	# this multiplier will be applied to the enemy_unit_priority from
	# the war stance on targeting enemy units. 
	#
	CLOSE_TO_VICTORY_REMAINING_BATTLE_MULTIPLIER = 2.0

	### Brief: POTENTIAL_PROVINCE_TARGET_ADJACENT_TO_FRIENDLY_SCORE ( int )
	# When deciding where to send its armies, locations that are 
	# adjacent to a friendly controlled county are given extra score
	#
	POTENTIAL_PROVINCE_TARGET_ADJACENT_TO_FRIENDLY_SCORE = 100

	# How much space to reserve for various lookup tables. Only affects performance
	PROVINCE_LOOKUP_SIZE_HINT = 64
	COUNTY_LOOKUP_SIZE_HINT = 128
	UNIT_LOOKUP_SIZE_HINT = 256
	
	### Brief: GHW_ATTACKER_DESPERATE_THRESHOLD ( Fixed point )
	# Below this strength ratio, the attacker enters desperate mode if 
	# the normal requirements haven't yet been met
	#
	GHW_ATTACKER_DESPERATE_THRESHOLD = 0.75				

	### Brief: GHW_DEFENDER_DESPERATE_THRESHOLD ( Fixed point )
	# Below this strength ratio, the defender enters desperate mode if 
	# the normal requirements haven't yet been met
	#
	GHW_DEFENDER_DESPERATE_THRESHOLD = 0.5				
	
	### Brief: IS_DESPERATE_WARSCORE_THRESHOLDS ( array of ints )
	# Primary defenders realm size. Indices for these values map into
	# IS_DESPERATE_WARSCORE_THRESHOLDS for when the AI starts getting
	# desperate. 
	#
	IS_DESPERATE_REALM_SIZE_THRESHOLDS = {				
		5
		10
		15
	}

	### Brief: IS_DESPERATE_WARSCORE_THRESHOLDS ( array of ints )
	# The attacker's war score. When opposing war score is above this
	# value, the AI is classed as desperate.
	#
	IS_DESPERATE_WARSCORE_THRESHOLDS = {				
		25
		50
		75
	}

	### Brief: DISEMBARK_POWER_PENALTY ( FixedPoint )
	# Multiplier to apply to a embarked unit's power projection onto
	# a province.
	#
	DISEMBARK_POWER_PROJECTION_PENALTY = 0.5

	### Brief: LOPSIDED_WAR_RATIO_THRESHOLD ( Fixed Point )
	# When is a war defined as being lopsided, when 
	# min( allied power, enemy power ) / max( allied power, enemy power )
	#
	LOPSIDED_WAR_RATIO_THRESHOLD = 0.33

	### Brief: DEFENDER_SAFE_RAISE_ARMY_DISTANCE (int32)
	# How many counties away to check for hostile counties and/or hostile 
	# armies when looking for a safe county to raise armies in. If set to 0, it 
	# will check the county itself and its neighbouring provinces. 	
	#
	# Warning: Drastically increases complexity of army raising logic when 
	# 	increased. 
	#
	# Must be greater or equal to 0
	DEFENDER_SAFE_RAISE_ARMY_DISTANCE = 1 		

	### Brief: ATTACKER_SAFE_RAISE_ARMY_DISTANCE (int32)
	# How many counties away to check for hostile counties and/or hostile 
	# armies when looking for a safe county to raise armies in. If set to 0, it
	# will check the county itself and its neighbouring provinces.
	#
	# Warning: Drastically increases complexity of army raising logic when 
	# 	increased. 
	#
	# Must be greater or equal to 0
	ATTACKER_SAFE_RAISE_ARMY_DISTANCE = 1 	

	### Brief: NUM_SAFE_COUNTIES_FOR_IMPROVED_RAISING ( int32 )
	# Once county distances to war goal counties has been calculated, how many
	# of these will be used to select the actual raise county? Picks the from
	# defined closest counties.
	#
	# Must be greater or equal to 0	
	NUM_SAFE_COUNTIES_FOR_IMPROVED_RAISING = 5
	
	### Brief: LAST_STAND_CAPITAL_SCORE ( int32 ) 
	# Score added to capital province when picking a final stand
	# province while desperate (Should together with second best
	# terrain advantage be less than best terrain advantage)
	#
	LAST_STAND_CAPITAL_SCORE = 5

	### Brief: LAST_STAND_OCCUPIED_SCORE ( int32 ) 
	# Score added for provinces already occupied by the enemy, prefer
	# making a stand in an unoccupied province to force the enemy into
	# combat
	#
	LAST_STAND_OCCUPIED_SCORE = -1000
	
	### Brief: DESPERATE_UNIT_MIN_SIZE ( int32 ) 
	# The AI will not make desperate last stands or attacks with units
	# smaller than this
	#
	DESPERATE_UNIT_MIN_SIZE = 150						
	
    ### Brief: PLAYER_SUPPORT_WANTED_COMBAT_RATIO ( Fixed Point )
    # Try to call in nearby allied AI units until this strength ratio 
    # is met.
    #
    PLAYER_SUPPORT_WANTED_COMBAT_RATIO = 5.0

    ### Brief: PLAYER_SUPPORT_ATTACK_TARGET_MAX_DISTANCE ( int32 )
    # If the first enemy unit on the player unit's path is further 
    # away than this, the AI units in support will ignore it and 
    # instead find better things to do around the player unit.
    #
    PLAYER_SUPPORT_ATTACK_TARGET_MAX_DISTANCE = 400

    ### Brief: PLAYER_SUPPORT_ATTACK_MAX_ARRIVAL_DELAY ( int32 )
    # Ignore to help out in the attack if estimated arrival is this 
    # many days after the combat starts.
    #
    PLAYER_SUPPORT_ATTACK_MAX_ARRIVAL_DELAY = 45

    ### Brief: PLAYER_SUPPORT_IGNORE_BAD_SUPPLY_WITHIN_STEPS ( int32 )
    # Ignore trying to re-route to avoid bad supply situations when 
    # within this many steps from the target province.
    #
    PLAYER_SUPPORT_IGNORE_BAD_SUPPLY_WITHIN_STEPS = 4

    ### Brief: PLAYER_SUPPORT_ENEMY_POWER_MULTIPLIER ( Fixed Point )
    # The AI will overestimate enemy strength with this multiplier 
    # when calculating how many troops should support a player unit.
    #
    PLAYER_SUPPORT_ENEMY_POWER_MULTIPLIER = 1.5

    ### Brief: PLAYER_SUPPORT_MIN_SIEGE_STRENGTH ( Fixed Point )
    # The AI will try to add enough troops supporting a player unit to 
    # reach a total number that is higher than the largest enemy 
    # garrison times this number.
    #
    PLAYER_SUPPORT_MIN_SIEGE_STRENGTH = 1.25

    ### Brief: TARGET_SCORE_SUPPORT_PLAYER_ONE_STEP ( int32 )
    # Added to score when supporting a player unit, and target 
    # province is one step away.
    #
    TARGET_SCORE_SUPPORT_PLAYER_ONE_STEP = 1000

    ### Brief: TARGET_SCORE_SUPPORT_PLAYER_TWO_STEP ( int32 )
    # Added to score when supporting a player unit, and target 
    # province is two steps away.
    #
    TARGET_SCORE_SUPPORT_PLAYER_TWO_STEP = 500

    ### Brief: TARGET_SCORE_SUPPORT_PLAYER_THREE_STEP ( int32 )
    # Added to score when supporting a player unit, and target 
    # province is three steps away.
    #
    TARGET_SCORE_SUPPORT_PLAYER_THREE_STEP = 250

    ### Brief: TARGET_SCORE_IS_SIEGING ( int32 )
    # Added to score if the specific AI unit evaluating is sieging 
    # the province.
    #
    TARGET_SCORE_IS_SIEGING = 500

    ### Brief: TARGET_SCORE_WOULD_LIFT_SIEGE ( int32 )
    # Added to score if moving to this province would lift a siege.
    #
    TARGET_SCORE_WOULD_LIFT_SIEGE = 190

    ### Brief: TARGET_SCORE_WOULD_START_COMBAT ( int32 )
    # Added to score if moving to this province would start a combat.
    #
    TARGET_SCORE_WOULD_START_COMBAT = 80

    ### Brief: TARGET_SCORE_WOULD_START_SIEGE ( int32 )
    # Added to score if moving to this province would start a siege.
    #
    TARGET_SCORE_WOULD_START_SIEGE = 70

    ### Brief: MAX_DISTANCE_SCORE_CLOSE_TO_WAR_GOAL ( int32 )
    # At what point do we stop giving extra score to sieging provinces 
    # close to the war goal? In pixels added to the war goal radius.
    #
    MAX_DISTANCE_SCORE_CLOSE_TO_WAR_GOAL = 75

    ### Brief: TARGET_SCORE_CLOSE_TO_WAR_GOAL ( int32 )
    # Added to score if not a war goal province but close enough to 
    # the war goal area.
    #
    TARGET_SCORE_CLOSE_TO_WAR_GOAL = 100

    ### Brief: TARGET_SCORE_SAME_PROVINCE ( int32 )
    # Bonus to targets in same province as unit.
    #
    TARGET_SCORE_SAME_PROVINCE = 25

    ### Brief: TARGET_SCORE_SAME_COUNTY ( int32 )
    # Bonus to targets in same county as unit.
    #
    TARGET_SCORE_SAME_COUNTY = 150

    ### Brief: TARGET_SCORE_SAME_COUNTY_AS_ENEMY_CAPITAL ( int32 )
    # Bonus to targets in same county as enemy capital if unit is in 
    # same or adjacent county.
    #
    TARGET_SCORE_SAME_COUNTY_AS_ENEMY_CAPITAL = 75

    ### Brief: TARGET_SCORE_NEIGHBOR_COUNTY ( int32 )
    # Bonus to targets in neighboring counties as unit.
    #
    TARGET_SCORE_NEIGHBOR_COUNTY = 100

    ### Brief: TARGET_SCORE_CURRENT ( int32 )
    # Bonus to picking the current target.
    #
    TARGET_SCORE_CURRENT = 100

    ### Brief: TARGET_SCORE_FURTHER_AWAY ( int32 )
    # Penalty to targets further away from the current target, than the
    # unit is to the current target.
    #
    TARGET_SCORE_FURTHER_AWAY = -100

    ### Brief: TARGET_WILL_BREAK_ONGOING_SIEGE ( int32 )
    # Penalty to targets if going after them would break an ongoing
    # siege while the AI's side still can get war score from sieges.
    #
    # This value will be multiplied by how far away from the cap of 
    # siege warscore you can get as a percentile.
    #
    # For example: 
    # 	1. 	AI can get 50 War Score from occupations and currently has
    #		10. This will result in this value being multiplied by
    #		40/50.
    #
    TARGET_WILL_BREAK_ONGOING_SIEGE = -100

    ### Brief: TARGET_WILL_CONTINUE_ONGOING_SIEGE ( int32 )
    # Bonus to target already under siege by one of the stack's
	# subunit stacks. Should be slightly higher than the score
	# for starting a new siege.
    #
    TARGET_WILL_CONTINUE_ONGOING_SIEGE = 80

    ### Brief: APPLY_TARGET_WILL_BREAK_ONGOING_SIEGE_RATIO ( Fixed Point )
    # Determines when TARGET_WILL_BREAK_ONGOING_SIEGE will be applied
    # based on the ratio of available war score from occupations and
    # the maximum obtainable war score from the casus belli.
    #
    # For example:
    # 	1.	The AI can get 100 War Score from occupations and currently
    #		has 30. At 0.5 will lead to TARGET_WILL_BREAK_ONGOING_SIEGE 
    #		being applied, because it is only at 70% of the available
    #		war score.
    #	2. 	The AI can get 100 War Score from occupations and currently
    #		has 70. At 0.5 will lead to TARGET_WILL_BREAK_ONGOING_SIEGE 
    #		not being applied, because it is only at 70% of the
    #		available war score.
    #
    APPLY_TARGET_WILL_BREAK_ONGOING_SIEGE_RATIO = 0.5

	### Brief: MAX_DAYS_LEFT_TO_LIFT_SIEGE_WITHOUT_SIEGE_WEAPONS ( INT32 )
	# If a unit stack can abandon a siege done by a subunit stack due
	# to lack of siege weapons, it will do so only if the calculated days
	# until the siege ends is equal or higher than this value.
	#
	MAX_DAYS_LEFT_TO_LIFT_SIEGE_WITHOUT_SIEGE_WEAPONS = 30
	
    ### Brief: MIN_CULTURE_TRAIT_SCORE_COMPARED_TO_BEST_SCORE ( Fixed Point )
    # When selecting a tradition or pillar, anything below this 
    # compared to the highest score is discarded.
    #
    MIN_CULTURE_TRAIT_SCORE_COMPARED_TO_BEST_SCORE = 0.6

    ### Brief: DIVERGENCE_TRADITIONS_TO_REPLACE ( int32 )
    # When diverging, the AI will replace this # of traditions.
    #
    DIVERGENCE_TRADITIONS_TO_REPLACE = 2

    ### Brief: CURRENT_COURT_TYPE_SETTING_ADDED_WEIGHT ( int32 )
    # Extra value added to the currently active court type setting 
    # when calculating weight so we do not flip back and forth between 
    # closely weighted settings.
    #
    CURRENT_COURT_TYPE_SETTING_ADDED_WEIGHT = 50

    ### Brief: MIN_SCORE_RATIO_FOR_COURT_POSITION_HIRE ( Fixed Point )
    # When selecting a court position to hire, anything below this 
    # compared to the highest score is discarded.
    #
    MIN_SCORE_RATIO_FOR_COURT_POSITION_HIRE = 0.6

    ### Brief: COURT_AMENITY_MIN_TARGET_EXPENDITURE_PERCENTAGE_OF_INCOME
    # Min target expenditure value in % of income for court amenities.
    #
    # When between the min and max, the AI will try to make its
    # baseline equal or greater to its expected court grandeur value
	# ai_amenity_target_baseline can modify this. 0.1 means it'll
	# pretend the expected value is 10% higher ai_amenity_spending
	# modifies the min and max
    #
    COURT_AMENITY_MIN_TARGET_EXPENDITURE_PERCENTAGE_OF_INCOME = 0.05

    ### Brief: COURT_AMENITY_MAX_TARGET_EXPENDITURE_PERCENTAGE_OF_INCOME
    # Max target expenditure value in % of income for court amenities.
    #
    # When between the min and max, the AI will try to make its
    # baseline equal or greater to its expected court grandeur value
	# ai_amenity_target_baseline can modify this. 0.1 means it'll
	# pretend the expected value is 10% higher ai_amenity_spending
	# modifies the min and max
    #
    COURT_AMENITY_MAX_TARGET_EXPENDITURE_PERCENTAGE_OF_INCOME = 0.20
	
	### Brief: GATHERING_DAYS_FOR_GREAT_HOLY_WAR ( int32 )
    # Number of days the AI spend trying to gather as many units
    # as possible in the designated gathering province before
	# moving towards the staging province
	#
    GATHERING_DAYS_FOR_GREAT_HOLY_WAR = 300

	### Brief: MAX_STAGING_DAYS_FOR_GREAT_HOLY_WAR ( int32 )
    # The maximum number of days that the AI spend waiting for
    # its units to arrive inthe designated staging province before
	# moving towards the intended target
	#
	# Should enough units arrive before this date, the AI will
	# stop staging
	#
    MAX_STAGING_DAYS_FOR_GREAT_HOLY_WAR = 300
	
	### Brief: MIN_POWER_ARRIVED_TO_STOP_STAGING_FOR_GREAT_HOLY_WAR ( Fixed Point )
    # The minimum amount of the AI's total power that needs to have
	# arrived in the staging province for it to stop staging
	#
    MIN_POWER_ARRIVED_TO_STOP_STAGING_FOR_GREAT_HOLY_WAR = 0.9
}

NFaction = {
    ### Brief: CREATE_OPINION_THRESHOLD ( int32 )
    # An opinion below this value will give the AI a chance to create
    # a faction.
    #
    CREATE_OPINION_THRESHOLD = 75

    ### Brief: CREATE_MIN_SCORE ( int32 )
    # Minimum score value to attempt to create a faction.
    #
    CREATE_MIN_SCORE = 15

    ### Brief: JOIN_OPINION_THRESHOLD ( int32 )
    # An opinion below this value will give the AI a chance to join
    # a faction.
    #
    JOIN_OPINION_THRESHOLD = 75

    ### Brief: JOIN_MIN_SCORE ( int32 )
    # Minimum score value to attempt to join a faction.
    #
    JOIN_MIN_SCORE = 15

    ### Brief: LEAVE_SCORE_THRESHOLD ( int32 )
    # If the join score goes below this value, the member will leave
    # the faction.
    #
    LEAVE_SCORE_THRESHOLD = 5

    ### Brief: DEMAND_EXTRA_THRESHOLD ( int32 )
    # The AI will wait until its power and demand total exceeds the
    # threshold plus this value before pressing demands.
    #
    DEMAND_EXTRA_THRESHOLD = 20

    ### Brief: DREAD_MODIFIED_BOLDNESS_FACTOR ( Fixed Point )
    # The effect of Boldness, modified by the liege's Dread, on the AI
    # when considering creating or joining a faction. Boldness cannot
    # make a negative evaluation score positive.
    #
    DREAD_MODIFIED_BOLDNESS_FACTOR = 1.0

    ### Brief: RATIONALITY_FACTOR ( Fixed Point )
    # The effect of Rationality on the AI when considering creating or
    # joining a faction. Rationality can adjust the evaluation score
    # above or below 0.
    #
    RATIONALITY_FACTOR = 1.0

    ### Brief: ENERGY_FACTOR ( Fixed Point )
    # The effect of Energy on the AI when considering creating or
    # joining a faction. Energy or Lethargy can only modify an already
    # positive evaluation score.
    #
    ENERGY_FACTOR = 1.0


}

NCourtPositions = {
    ### Brief: MAX_SCORE_TO_FIRE_COURT_POSITION ( int32 )
    # Threshold for "ai_will_do" in Court Positions for the AI to begin
    # firing Court Position holders.
    #
    MAX_SCORE_TO_FIRE_COURT_POSITION = -50

    ### Brief: MIN_SCORE_TO_HIRE_COURT_POSITION ( int32 )
    # Threshold for "ai_will_do" in Court Positions for the AI to hire
    # a Court Position.
    #
    MIN_SCORE_TO_HIRE_COURT_POSITION = 0

    ### Brief: COURT_POSITION_TASK_SWITCH_SCORE ( Fixed Point )
    # For the AI to switch to a different task type, the new task
    # score must be at least the current task score multiplied by this.
    # A value of 1.25 means it needs to be 25% higher.
    #
    COURT_POSITION_TASK_SWITCH_SCORE = 1.25

    ### Brief: MIN_SCORE_TO_START_COURT_POSITION_TASK ( int32 )
    # Threshold for "ai_will_do" in Court Positions Task types for the
    # AI to start tasks. Inactive tasks with this score or higher are
    # considered.
    #
    MIN_SCORE_TO_START_COURT_POSITION_TASK = 0

    ### Brief: MAX_SCORE_TO_STOP_COURT_POSITION_TASK ( int32 )
    # Threshold for "ai_will_do" in Court Positions Task types for the
    # AI to begin stopping tasks. Active tasks with scores below or
    # equal to this will be stopped.
    #
    MAX_SCORE_TO_STOP_COURT_POSITION_TASK = -10

}

NInventory = {
    ### Brief: ARTIFACT_REPAIR_DURABILITY_PERCENTAGE_THRESHOLD (Fixed Point)
    # Artifact durability threshold for when the AI will repair an
    # artifact, percentage of max durability.
    #
    ARTIFACT_REPAIR_DURABILITY_PERCENTAGE_THRESHOLD = 0.1

    ### Brief: ARTIFACT_REFORGE_DURABILITY_PERCENTAGE_THRESHOLD (Fixed Point)
    # Artifact durability threshold for when the AI will reforge an
    # artifact, percentage of max durability.
    #
    ARTIFACT_REFORGE_DURABILITY_PERCENTAGE_THRESHOLD = 0.1

NActivity = {
    ### Brief: ACTIVITY_SCORE_THRESHOLD ( int32 )
    # Activities with scores above this threshold will be eligible
    # for hosting.
    #
    ACTIVITY_SCORE_THRESHOLD = 20

NTaxSlot = {
    ### Brief: MIN_SCORE_TO_HIRE_TAX_COLLECTOR ( int32 )
    # Threshold for tax_collector_score for the AI to consider
    # hiring a candidate as a tax collector.
    #
    MIN_SCORE_TO_HIRE_TAX_COLLECTOR = 0

    ### Brief: MAX_SCORE_TO_FIRE_TAX_COLLECTOR ( int32 )
    # Threshold for tax_collector_score for the AI to fire them,
    # anything below this will be fired.
    #
    MAX_SCORE_TO_FIRE_TAX_COLLECTOR = -25

    ### Brief: MIN_SCORE_RATIO_FOR_TAX_COLLECTOR_HIRE ( Fixed Point )
    # When selecting a tax collector to hire, candidates with a
    # score below this ratio compared to the highest score are
    # discarded.
    #
    MIN_SCORE_RATIO_FOR_TAX_COLLECTOR_HIRE = 0.6

    ### Brief: USE_EMPLOYED_CHARACTER_TO_HIRE_CHANCE ( Fixed Point )
    # Chance to use an already assigned tax collector for a new
    # tax slot, moving them from the current slot to a new one.
    #
    USE_EMPLOYED_CHARACTER_TO_HIRE_CHANCE = 0.15
}
